{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dispike \u2699\ufe0f A simple to use, powerful framework for creating stateless, independent bots using Discord Slash Commands. \u26a1 Powered by FastAPI. Before we start. \u00b6 This library is currently in beta. While things are more stable than earlier releases, breaking changes can still be introduced. It's recommended to stay in the loop with the repository such as joining our Discord server for announcements. This library assumes you will be building an independent server to receive and send requests from/to Discord directly. This may cause higher bandwidth usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this , or use a \"serverless\" platform such as Amazon Lambda (with an adapter) or Google Cloud App Engine. If you want to do local testing before creating a server, you can use free tools such as Ngrok . Join our Discord Server for discussion and help This library is only tested on python versions 3.9 3.8 ^* 3.7 3.6 API Parity List \u00b6 Info Just because it's been implemented does not mean it's in the best way. Help out by contributing to this library! API Endpoint Implementation Get Global Application Commands \u2705 Implemented Create Global Application Command \u2705 Implemented Edit Global Application Command \u2705 Implemented Delete Global Application Command \u2705 Implemented Create Guild Application Command \u2705 Implemented Edit Guild Application Command \u2705 Implemented Delete Guild Application Command \u2705 Implemented Create Interaction Response \u2705 Implemented Edit Original Interaction Response \u2705 Implemented Delete Original Interaction Response \u2705 Implemented Create Followup Message \u2705 Implemented Edit Followup Message \u2705 Implemented Delete Followup Message \u2705 Implemented Data Models and Types \u2705 Implemented ApplicationCommand \u2705 Implemented ApplicationCommandOption \u2705 Implemented ApplicationCommandOptionType \u2705 Implemented ApplicationCommandOptionChoice \u2705 Implemented Interaction \u2705 Implemented Interaction Response \u2705 Implemented Message Components \u2705 Implemented Buttons (Message Components) \u2705 Implemented Action Rows (Message Components) \u2705 Implemented Message Select (Message Components) \u2705 Implemented Message Attachments \u26a0\ufe0f Not Implemented Special Thanks \u00b6 Squidtoon99 marshmallow Coverage tested on this version of python. \u21a9","title":"Home"},{"location":"#before-we-start","text":"This library is currently in beta. While things are more stable than earlier releases, breaking changes can still be introduced. It's recommended to stay in the loop with the repository such as joining our Discord server for announcements. This library assumes you will be building an independent server to receive and send requests from/to Discord directly. This may cause higher bandwidth usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this , or use a \"serverless\" platform such as Amazon Lambda (with an adapter) or Google Cloud App Engine. If you want to do local testing before creating a server, you can use free tools such as Ngrok . Join our Discord Server for discussion and help This library is only tested on python versions 3.9 3.8 ^* 3.7 3.6","title":"Before we start."},{"location":"#api-parity-list","text":"Info Just because it's been implemented does not mean it's in the best way. Help out by contributing to this library! API Endpoint Implementation Get Global Application Commands \u2705 Implemented Create Global Application Command \u2705 Implemented Edit Global Application Command \u2705 Implemented Delete Global Application Command \u2705 Implemented Create Guild Application Command \u2705 Implemented Edit Guild Application Command \u2705 Implemented Delete Guild Application Command \u2705 Implemented Create Interaction Response \u2705 Implemented Edit Original Interaction Response \u2705 Implemented Delete Original Interaction Response \u2705 Implemented Create Followup Message \u2705 Implemented Edit Followup Message \u2705 Implemented Delete Followup Message \u2705 Implemented Data Models and Types \u2705 Implemented ApplicationCommand \u2705 Implemented ApplicationCommandOption \u2705 Implemented ApplicationCommandOptionType \u2705 Implemented ApplicationCommandOptionChoice \u2705 Implemented Interaction \u2705 Implemented Interaction Response \u2705 Implemented Message Components \u2705 Implemented Buttons (Message Components) \u2705 Implemented Action Rows (Message Components) \u2705 Implemented Message Select (Message Components) \u2705 Implemented Message Attachments \u26a0\ufe0f Not Implemented","title":"API Parity List"},{"location":"#special-thanks","text":"Squidtoon99 marshmallow Coverage tested on this version of python. \u21a9","title":"Special Thanks"},{"location":"FollowUpMessages/","text":"Follow Up Messages \u00b6 Follow-up messages are a feature that allows for responses to sent after an initial response has been already been sent. Info This module offers methods both in async and sync. Methods regarding editing and sending will require a DiscordResponse . \u00b6 __init__ ( self , bot , interaction ) special \u00b6 A module to handle Follow Up Messages. Parameters: Name Type Description Default bot Dispike An already initalized dispike object. required interaction IncomingDiscordInteraction An incoming Discord Interaction required Source code in dispike/followup/main.py def __init__ ( self , bot : \"Dispike\" , interaction : \"IncomingDiscordInteraction\" , ): \"\"\"A module to handle Follow Up Messages. Args: bot (Dispike): An already initalized dispike object. interaction (IncomingDiscordInteraction): An incoming Discord Interaction \"\"\" self . _application_id = bot . _application_id self . _interaction_token = interaction . token self . base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { self . _interaction_token } \" self . _async_client = httpx . AsyncClient ( base_url = self . base_url ) self . _sync_client = httpx . Client ( base_url = self . base_url ) self . _message_id = None async_create_follow_up_message ( self , message ) async \u00b6 Create an initial follow up message. (Async) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) async def async_create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Async) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if not isinstance ( message , DiscordResponse ): raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id is not None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = await self . _async_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise async_delete_follow_up_message ( self ) async \u00b6 Deletes an already sent initial follow-up message. (Async) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) async def async_delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (Async) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = await self . _async_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise async_edit_follow_up_message ( self , updated_message ) async \u00b6 Edit an already sent initial follow-up message. (Async) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) async def async_edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Async) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = await self . _async_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise create_follow_up_message ( self , message ) \u00b6 Create an initial follow up message. (Sync) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) def create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Sync) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if not isinstance ( message , DiscordResponse ): raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id is not None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = self . _sync_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise delete_follow_up_message ( self ) \u00b6 Deletes an already sent initial follow-up message. (sync) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) def delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (sync) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = self . _sync_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise edit_follow_up_message ( self , updated_message ) \u00b6 Edit an already sent initial follow-up message. (Sync) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) def edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Sync) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = self . _sync_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"Follow Up Messages"},{"location":"FollowUpMessages/#follow-up-messages","text":"Follow-up messages are a feature that allows for responses to sent after an initial response has been already been sent. Info This module offers methods both in async and sync. Methods regarding editing and sending will require a DiscordResponse .","title":"Follow Up Messages"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages","text":"","title":"dispike.followup.main.FollowUpMessages"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.__init__","text":"A module to handle Follow Up Messages. Parameters: Name Type Description Default bot Dispike An already initalized dispike object. required interaction IncomingDiscordInteraction An incoming Discord Interaction required Source code in dispike/followup/main.py def __init__ ( self , bot : \"Dispike\" , interaction : \"IncomingDiscordInteraction\" , ): \"\"\"A module to handle Follow Up Messages. Args: bot (Dispike): An already initalized dispike object. interaction (IncomingDiscordInteraction): An incoming Discord Interaction \"\"\" self . _application_id = bot . _application_id self . _interaction_token = interaction . token self . base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { self . _interaction_token } \" self . _async_client = httpx . AsyncClient ( base_url = self . base_url ) self . _sync_client = httpx . Client ( base_url = self . base_url ) self . _message_id = None","title":"__init__()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.async_create_follow_up_message","text":"Create an initial follow up message. (Async) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) async def async_create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Async) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if not isinstance ( message , DiscordResponse ): raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id is not None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = await self . _async_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"async_create_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.async_delete_follow_up_message","text":"Deletes an already sent initial follow-up message. (Async) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) async def async_delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (Async) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = await self . _async_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"async_delete_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.async_edit_follow_up_message","text":"Edit an already sent initial follow-up message. (Async) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) async def async_edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Async) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = await self . _async_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"async_edit_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.create_follow_up_message","text":"Create an initial follow up message. (Sync) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) def create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Sync) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if not isinstance ( message , DiscordResponse ): raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id is not None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = self . _sync_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"create_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.delete_follow_up_message","text":"Deletes an already sent initial follow-up message. (sync) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) def delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (sync) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = self . _sync_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"delete_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.edit_follow_up_message","text":"Edit an already sent initial follow-up message. (Sync) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py @logger . catch ( reraise = True ) def edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Sync) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id is None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = self . _sync_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise","title":"edit_follow_up_message()"},{"location":"APIRef/Dispike/","text":"Dispike \u00b6 Initalizing Dispike will require - A valid client public key - A valid bot token - A valid client id (Dispike references this as an application id.) All of these values can be found in the Discord Developer Portal. Run command \u00b6 The run method is available as a convenience to quickly start a HTTP server that can accept connections. While this HTTP server itself is production-ready, you should run this behind a reverse-proxy such as Nginx , Apache or Caddy. - Recommended \u00b6 Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Run the bot on a specific port. None unix_socket str [description]. Run the bot and listen on a specific unix domain socket.. None Exceptions: Type Description ArgumentError Raised if you pass both a port and a unix socket. Source code in dispike/main.py def run ( self , port : int = None , unix_socket : str = None , bind_to_ip_address : str = None , supress_insecure_binding_warning : bool = False , ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Run the bot on a specific port. unix_socket (str, optional): [description]. Run the bot and listen on a specific unix domain socket.. Raises: ArgumentError: Raised if you pass both a port and a unix socket. \"\"\" uvicorn = self . _return_uvicorn_run_function () if unix_socket and port : raise ValueError ( \"You cannot bind to port AND a unix socket\" ) else : if port : if bind_to_ip_address : if supress_insecure_binding_warning == False : warnings . warn ( \"Binding to a IP Address other than 127.0.0.1 may not be secure! If you are exposing this service to the outside world -- a reverse proxy is strongly recommended.\" , InsecureBindingWithCustomHostWarning , ) uvicorn . run ( app = self . referenced_application , host = bind_to_ip_address , port = port , ) else : uvicorn . run ( app = self . referenced_application , port = port ) elif unix_socket : if \"unix\" not in unix_socket : unix_socket = f \"unix: { unix_socket } \" else : uvicorn . run ( self . referenced_application , host = unix_socket ) if not unix_socket and not port : raise ValueError ( \"You must specify a port or unix socket\" ) Dispike Reference \u00b6 \u00b6 Dispike \u00b6 An independent, simple to use, powerful framework for creating interaction-based Discord bots. Powered by FastAPI interaction property readonly \u00b6 This is deprecated and will be removed in a future version of dispike! \u00b6 use self.on instead. This method returns self.on to ensure compatiablity with the previous versions of dispike. referenced_application: FastAPI property readonly \u00b6 Returns the internal FastAPI object that was initialized. You are welcome to edit this with the appropriate settings found in the FastAPI docs. Returns: Type Description FastAPI FastAPI: a pre-configured FastAPI object with required middlewares. register: < function RegisterCommands . register at 0x7f7c780fc0e0 > property readonly \u00b6 Returns a shortcut the RegisterCommands.register function Returns: Type Description <function RegisterCommands.register at 0x7f7c780fc0e0> RegisterCommands.register: internal RegisterCommands Object shared_client: httpx . Client property readonly \u00b6 Returns a pre-initialized httpx.Client that is used for requests internally. Returns: Type Description httpx.Client httpx.Client: used for network requests to discord. __init__ ( self , client_public_key , application_id , bot_token = None , ** kwargs ) special \u00b6 Initialize Dispike Object Parameters: Name Type Description Default client_public_key str Discord provided client public key. required bot_token str Discord provided bot token. Optional, but if you do not provide a bot token, you cannot register commands. None application_id str Discord provided Client ID required custom_context_argument_name str Change the name of the context arugment when passing to a function. Set to \"ctx\". required middleware_testing_skip_verification_key_request (bool, optional): Skip middleware verification (NOT RECOMMENDED) required Source code in dispike/main.py def __init__ ( self , client_public_key : str , application_id : str , bot_token : str = None , ** kwargs , ): \"\"\"Initialize Dispike Object Args: client_public_key (str): Discord provided client public key. bot_token (str): Discord provided bot token. Optional, but if you do not provide a bot token, you cannot register commands. application_id (str): Discord provided Client ID custom_context_argument_name (str, optional): Change the name of the context arugment when passing to a function. Set to \"ctx\". middleware_testing_skip_verification_key_request: (bool, optional): Skip middleware verification (NOT RECOMMENDED) \"\"\" self . _bot_token = bot_token self . _application_id = application_id if bot_token is not None : self . _registrator = RegisterCommands ( application_id = self . _application_id , bot_token = self . _bot_token ) else : self . _registrator = False self . _internal_application = FastAPI () if kwargs . get ( \"middleware_testing_skip_verification_key_request\" , False ): self . _testing_skip_verification_key_request = True else : self . _testing_skip_verification_key_request = False self . _internal_application . add_middleware ( DiscordVerificationMiddleware , client_public_key = client_public_key , testing_skip_verification_of_key = self . _testing_skip_verification_key_request , ) self . _internal_application . include_router ( router = router ) if not kwargs . get ( \"custom_context_argument_name\" ): router . _user_defined_setting_ctx_value = \"ctx\" else : router . _user_defined_setting_ctx_value = kwargs . get ( \"custom_context_argument_name\" ) self . callbacks = { \"command\" : {}, \"component\" : {}, \"message_command\" : {}, \"user_command\" : {}, } self . _cache_router = router self . _client = httpx . Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" , event_hooks = { \"response\" : [ dispike_httpx_event_hook_incoming_request ], \"request\" : [ dispike_httpx_event_hook_outgoing_request ], }, ) async_get_all_command_permissions_in_guild ( self , guild_id ) async \u00b6 Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.creating.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py async def async_get_all_command_permissions_in_guild ( self , guild_id ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" ) if _request_command_permission . status_code not in [ 200 , 201 ]: raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except DiscordAPIError : raise async_get_command_permission_in_guild ( self , command_id , guild_id ) async \u00b6 Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py async def async_get_command_permission_in_guild ( self , command_id , guild_id ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" ) if _request_command_permission . status_code == 404 : return None elif _request_command_permission . status_code == 200 : return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) else : raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) except DiscordAPIError : logger . error ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) raise async_set_command_permission ( self , command_id , guild_id , new_permissions ) async \u00b6 Set permissions for a command in a specific guild. This function is async! Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Either a command id int or a IncomingApplicationCommand (obtained from .get_command) required guild_id int The guild to be targeted. required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool bool: True, if the command has been successfully edited. Source code in dispike/main.py async def async_set_command_permission ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set permissions for a command in a specific guild. This function is async! Args: command_id (typing.Union[int, IncomingApplicationCommand]): Either a command id int or a IncomingApplicationCommand (obtained from .get_command) guild_id (int): The guild to be targeted. new_permissions (NewApplicationPermission): Permissions for this command. Returns: bool: True, if the command has been successfully edited. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) async with httpx . AsyncClient () as client : try : _set_command_permissions = await client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , data = new_permissions . dict (), headers = self . return_bot_token_headers (), ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) return False check_event_exists ( self , event , type ) \u00b6 Checks if the event in .callbacks Parameters: Name Type Description Default event str event name required Returns: Type Description bool bool: returns if the event is in callbacks. Source code in dispike/main.py def check_event_exists ( self , event : str , type : str ) -> bool : \"\"\"Checks if the event in ``.callbacks`` Args: event (str): event name Returns: bool: returns if the event is in callbacks. \"\"\" return event in self . callbacks [ type ] clear_all_event_callbacks ( self , event_type = None ) \u00b6 Clears all event callbacks. Source code in dispike/main.py def clear_all_event_callbacks ( self , event_type : \"EventTypes\" = None ): \"\"\"Clears all event callbacks.\"\"\" if not event_type : self . callbacks = { \"command\" : {}, \"component\" : {}} else : self . callbacks [ event_type ] = {} delete_command ( self , command_id , guild_only = False , guild_id_passed = None ) \u00b6 Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with deleting commands from Discord\" ) def delete_command ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (typing.Union[int, IncomingApplicationCommand]): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise edit_command ( self , new_command , command_id = None , bulk = False , guild_only = False , guild_id_passed = False ) \u00b6 Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID None new_command Union[List[dispike.creating.models.options.DiscordCommand], dispike.creating.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with editing commands from Discord\" ) def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : typing . Union [ int , IncomingApplicationCommand ] = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if command_id : if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : # TODO: Maybe don't return false and just raise it? logger . exception ( \"Discord API Failure.\" ) return False emit ( self , event , type , * args , ** kwargs ) async \u00b6 'Emits' an event. It will basically call the function from .callbacks and return the function result Parameters: Name Type Description Default event str Event name required type str Event type required *args extra arguments to pass () **kwargs extra kwargs to pass {} Returns: Type Description function result returns the function result Exceptions: Type Description TypeError raises if event is not registered. Source code in dispike/main.py async def emit ( self , event : str , type : str , * args , ** kwargs ): \"\"\"'Emits' an event. It will basically call the function from .callbacks and return the function result Args: event (str): Event name type (str): Event type *args: extra arguments to pass **kwargs: extra kwargs to pass Returns: function result: returns the function result Raises: TypeError: raises if event is not registered. \"\"\" if event not in self . callbacks [ type ]: raise TypeError ( f \"event { event } does not have a corresponding handler. Did you register this function/event?\" ) _look_up_function = self . return_event_function ( event , type ) return await _look_up_function ( * args , ** kwargs ) get_all_command_permissions_in_guild ( self , guild_id ) \u00b6 Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.creating.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py def get_all_command_permissions_in_guild ( self , guild_id : typing . Union [ str , int ] ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" , headers = self . return_bot_token_headers (), ) if _request_command_permission . status_code not in [ 200 , 201 ]: raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except DiscordAPIError : raise get_command_permission_in_guild ( self , command_id , guild_id ) \u00b6 Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py def get_command_permission_in_guild ( self , command_id : typing . Union [ str , int ], guild_id : typing . Union [ str , int ] ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , headers = self . return_bot_token_headers (), ) if _request_command_permission . status_code == 404 : return None elif _request_command_permission . status_code == 200 : return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) else : raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) except DiscordAPIError : logger . error ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) raise get_commands ( self , guild_only = False , guild_id_passed = None ) \u00b6 Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.incoming.incoming_interactions.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with getting commands from Discord\" ) def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only : if not guild_id_passed or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise on ( self , event , type =< EventTypes . COMMAND : 'command' > , func = None ) \u00b6 A wrapper over an async function, registers it in .callbacks. Parameters: Name Type Description Default event str Event name required type EventTypes Type of this event. <EventTypes.COMMAND: 'command'> func Callable function to wrap around None Returns: Type Description <function> returns the wrapped function Source code in dispike/main.py def on ( self , event : str , type : EventTypes = EventTypes . COMMAND , func : typing . Callable = None , ): \"\"\"A wrapper over an async function, registers it in .callbacks. Args: event (str): Event name type (EventTypes): Type of this event. func (None, optional): function to wrap around Returns: <function>: returns the wrapped function \"\"\" if isinstance ( type , ( EventTypes , str )): # TODO: This is broken, the only way we can show this warning is by # checking if the value is an Enum, which requires builtin-type (which we overriden) \"\"\" if not isinstance(type, EventTypes): # pragma: no cover logger.warning( \"Passing a unknown EventType, this may cause issues and is unsupported\" ) # noqa else: # TODO: Maybe it's not good to overrwrite a default python function. Maybe change type to a different value? raise InvalidEventType(type) # pragma: no cover \"\"\" else : raise InvalidEventType ( type ) def on ( func ): self . _add_function_to_callbacks ( event , type , func ) return func return on ( func ) if func else on register_collection ( self , collection , register_command_with_discord = False , initialze_on_load = False , initialization_arguments = None ) \u00b6 Registers a EventCollection. Parameters: Name Type Description Default collection EventCollection The collection to register. required Source code in dispike/main.py def register_collection ( self , collection : \"EventCollection\" , register_command_with_discord : bool = False , initialze_on_load : bool = False , initialization_arguments : typing . Dict = None , ): \"\"\"Registers a EventCollection. Args: collection (EventCollection): The collection to register. \"\"\" if initialze_on_load : collection = collection ( ** initialization_arguments ) _load_in_functions = self . _detect_functions_with_event_decorator ( collection = collection , ) # TODO: Maybe re-enable this as a fallback? \"\"\" for shallow_function in collections.registered_commands(): self._add_function_to_callbacks( function=shallow_function, function_name=shallow_function._dispike_event_name, function_type=shallow_function._dispike_event_type, ) \"\"\" for shallow_function in _load_in_functions : self . _add_function_to_callbacks ( function = shallow_function , function_name = shallow_function . _dispike_event_name , function_type = shallow_function . _dispike_event_type , ) if register_command_with_discord : for command in collection . command_schemas (): if isinstance ( command , PerCommandRegistrationSettings ): self . register ( command = command . schema , guild_only = True , guild_to_target = command . guild_id , ) else : self . register ( command = command ) register_event_command ( self , function_event_name , function , function_type = None , ** kwargs ) \u00b6 This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Parameters: Name Type Description Default function_event_name str Function event name required function Callable Function to register. Must be async required function_type EventTypes [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. None Exceptions: Type Description AttributeError If function_type is not a string or None, and it cannot be found in the functions attributes. Source code in dispike/main.py def register_event_command ( self , function_event_name : str , function : typing . Callable , function_type : EventTypes = None , ** kwargs , ): \"\"\"This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Args: function_event_name (str): Function event name function (typing.Callable): Function to register. Must be async function_type (EventTypes): [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. Raises: AttributeError: If function_type is not a string or None, and it cannot be found in the functions attributes. \"\"\" if function_type is None : # try to see if the function has a _event_type attribute try : function_type = function . _dispike_event_type except AttributeError : raise AttributeError ( \"Unable to find function event type attribute inside function.. Did you add a decorator to this function?\" ) else : if isinstance ( function_type , EventTypes ): function_type = function_type self . _add_function_to_callbacks ( function_name = function_event_name , function_type = function_type , function = function , ) reset_registration ( self , new_bot_token = None , new_application_id = None ) \u00b6 This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Parameters: Name Type Description Default new_bot_token None Description None new_application_id None Description None Returns: Type Description TYPE bool Source code in dispike/main.py @logger . catch ( reraise = True ) def reset_registration ( self , new_bot_token = None , new_application_id = None ): \"\"\"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Args: new_bot_token (None, optional): Description new_application_id (None, optional): Description Returns: TYPE: bool \"\"\" if new_bot_token is None : _bot_token = self . _bot_token else : _bot_token = new_bot_token if new_application_id is None : _application_id = self . _application_id else : _application_id = new_application_id self . _registrator = RegisterCommands ( application_id = _application_id , bot_token = _bot_token ) self . _bot_token = _bot_token self . _application_id = _application_id return True return_event_function ( self , event , type ) \u00b6 Returns the function registered for the event. Parameters: Name Type Description Default event str Event name required type str Event typelogger.debug(f\"logMessage\") required Exceptions: Type Description TypeError If Event name is not in callbacks. Returns: Type Description dict dict: containing func and settings Source code in dispike/main.py def return_event_function ( self , event : str , type : str ) -> dict : \"\"\"Returns the function registered for the event. Args: event (str): Event name type (str): Event typelogger.debug(f\"logMessage\") Raises: TypeError: If Event name is not in callbacks. Returns: dict: containing func and settings \"\"\" if self . check_event_exists ( event , type ): return self . callbacks [ type ][ event ][ \"function\" ] raise TypeError ( f \"Event { event } is not in callbacks. Did you register this event?\" ) run ( self , port = None , unix_socket = None , bind_to_ip_address = None , supress_insecure_binding_warning = False ) \u00b6 Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Run the bot on a specific port. None unix_socket str [description]. Run the bot and listen on a specific unix domain socket.. None Exceptions: Type Description ArgumentError Raised if you pass both a port and a unix socket. Source code in dispike/main.py def run ( self , port : int = None , unix_socket : str = None , bind_to_ip_address : str = None , supress_insecure_binding_warning : bool = False , ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Run the bot on a specific port. unix_socket (str, optional): [description]. Run the bot and listen on a specific unix domain socket.. Raises: ArgumentError: Raised if you pass both a port and a unix socket. \"\"\" uvicorn = self . _return_uvicorn_run_function () if unix_socket and port : raise ValueError ( \"You cannot bind to port AND a unix socket\" ) else : if port : if bind_to_ip_address : if supress_insecure_binding_warning == False : warnings . warn ( \"Binding to a IP Address other than 127.0.0.1 may not be secure! If you are exposing this service to the outside world -- a reverse proxy is strongly recommended.\" , InsecureBindingWithCustomHostWarning , ) uvicorn . run ( app = self . referenced_application , host = bind_to_ip_address , port = port , ) else : uvicorn . run ( app = self . referenced_application , port = port ) elif unix_socket : if \"unix\" not in unix_socket : unix_socket = f \"unix: { unix_socket } \" else : uvicorn . run ( self . referenced_application , host = unix_socket ) if not unix_socket and not port : raise ValueError ( \"You must specify a port or unix socket\" ) send_deferred_message ( self , original_context , new_message ) async \u00b6 Send a deferred message. Parameters: Name Type Description Default original_context IncomingDiscordSlashInteraction The orginal context of the message. required new_message DiscordResponse Message to send. required Source code in dispike/main.py async def send_deferred_message ( self , original_context : \"IncomingDiscordSlashInteraction\" , new_message : \"DiscordResponse\" , ): \"\"\"Send a deferred message. Args: original_context (IncomingDiscordSlashInteraction): The orginal context of the message. new_message (DiscordResponse): Message to send. \"\"\" async with httpx . AsyncClient ( base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { original_context . token } /messages/\" , headers = { \"Content-Type\" : \"application/json\" , }, ) as client : try : # TODO: Probably change later to inside the DeferredResponse? new_message . _switch_to_followup_message () logger . debug ( f \"sending deferred response : { new_message . response } \" ) response = await client . patch ( \"/@original\" , json = new_message . response ) response . raise_for_status () except httpx . HTTPError as req : logger . exception ( f \"Unable to send deferred message!\" ) raise set_command_permission ( self , command_id , guild_id , new_permissions ) \u00b6 Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Either a command id int or a IncomingApplicationCommand (obtained from .get_command) required guild_id int The guild to be targeted. required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool bool: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_id : int , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (typing.Union[int, IncomingApplicationCommand]): Either a command id int or a IncomingApplicationCommand (obtained from .get_command) guild_id (int): The guild to be targeted. new_permissions (NewApplicationPermission): Permissions for this command. Returns: bool: True, if the command has been successfully edited. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = self . return_bot_token_headers (), ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False view_event_function_return_type ( self , event , type ) \u00b6 Get type hint for event functions Parameters: Name Type Description Default event str Event name required Returns: Type Description dict dict: Returns .get_type_hints for event Source code in dispike/main.py def view_event_function_return_type ( self , event : str , type : str ) -> dict : \"\"\"Get type hint for event functions Args: event (str): Event name Returns: dict: Returns .get_type_hints for event \"\"\" return typing . get_type_hints ( self . callbacks [ type ][ event ][ \"function\" ])","title":"Dispike"},{"location":"APIRef/Dispike/#dispike_1","text":"Initalizing Dispike will require - A valid client public key - A valid bot token - A valid client id (Dispike references this as an application id.) All of these values can be found in the Discord Developer Portal.","title":"Dispike"},{"location":"APIRef/Dispike/#run-command","text":"The run method is available as a convenience to quickly start a HTTP server that can accept connections. While this HTTP server itself is production-ready, you should run this behind a reverse-proxy such as Nginx , Apache or Caddy. - Recommended","title":"Run command"},{"location":"APIRef/Dispike/#dispike.main.Dispike.run","text":"Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Run the bot on a specific port. None unix_socket str [description]. Run the bot and listen on a specific unix domain socket.. None Exceptions: Type Description ArgumentError Raised if you pass both a port and a unix socket. Source code in dispike/main.py def run ( self , port : int = None , unix_socket : str = None , bind_to_ip_address : str = None , supress_insecure_binding_warning : bool = False , ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Run the bot on a specific port. unix_socket (str, optional): [description]. Run the bot and listen on a specific unix domain socket.. Raises: ArgumentError: Raised if you pass both a port and a unix socket. \"\"\" uvicorn = self . _return_uvicorn_run_function () if unix_socket and port : raise ValueError ( \"You cannot bind to port AND a unix socket\" ) else : if port : if bind_to_ip_address : if supress_insecure_binding_warning == False : warnings . warn ( \"Binding to a IP Address other than 127.0.0.1 may not be secure! If you are exposing this service to the outside world -- a reverse proxy is strongly recommended.\" , InsecureBindingWithCustomHostWarning , ) uvicorn . run ( app = self . referenced_application , host = bind_to_ip_address , port = port , ) else : uvicorn . run ( app = self . referenced_application , port = port ) elif unix_socket : if \"unix\" not in unix_socket : unix_socket = f \"unix: { unix_socket } \" else : uvicorn . run ( self . referenced_application , host = unix_socket ) if not unix_socket and not port : raise ValueError ( \"You must specify a port or unix socket\" )","title":"dispike.main.Dispike.run"},{"location":"APIRef/Dispike/#dispike-reference","text":"","title":"Dispike Reference"},{"location":"APIRef/Dispike/#dispike.main.Dispike","text":"","title":"dispike.main.Dispike"},{"location":"APIRef/Dispike/#dispike","text":"An independent, simple to use, powerful framework for creating interaction-based Discord bots. Powered by FastAPI","title":"Dispike"},{"location":"APIRef/Dispike/#dispike.main.Dispike.interaction","text":"","title":"interaction"},{"location":"APIRef/Dispike/#this-is-deprecated-and-will-be-removed-in-a-future-version-of-dispike","text":"use self.on instead. This method returns self.on to ensure compatiablity with the previous versions of dispike.","title":"This is deprecated and will be removed in a future version of dispike!"},{"location":"APIRef/Dispike/#dispike.main.Dispike.referenced_application","text":"Returns the internal FastAPI object that was initialized. You are welcome to edit this with the appropriate settings found in the FastAPI docs. Returns: Type Description FastAPI FastAPI: a pre-configured FastAPI object with required middlewares.","title":"referenced_application"},{"location":"APIRef/Dispike/#dispike.main.Dispike.register","text":"Returns a shortcut the RegisterCommands.register function Returns: Type Description <function RegisterCommands.register at 0x7f7c780fc0e0> RegisterCommands.register: internal RegisterCommands Object","title":"register"},{"location":"APIRef/Dispike/#dispike.main.Dispike.shared_client","text":"Returns a pre-initialized httpx.Client that is used for requests internally. Returns: Type Description httpx.Client httpx.Client: used for network requests to discord.","title":"shared_client"},{"location":"APIRef/Dispike/#dispike.main.Dispike.__init__","text":"Initialize Dispike Object Parameters: Name Type Description Default client_public_key str Discord provided client public key. required bot_token str Discord provided bot token. Optional, but if you do not provide a bot token, you cannot register commands. None application_id str Discord provided Client ID required custom_context_argument_name str Change the name of the context arugment when passing to a function. Set to \"ctx\". required middleware_testing_skip_verification_key_request (bool, optional): Skip middleware verification (NOT RECOMMENDED) required Source code in dispike/main.py def __init__ ( self , client_public_key : str , application_id : str , bot_token : str = None , ** kwargs , ): \"\"\"Initialize Dispike Object Args: client_public_key (str): Discord provided client public key. bot_token (str): Discord provided bot token. Optional, but if you do not provide a bot token, you cannot register commands. application_id (str): Discord provided Client ID custom_context_argument_name (str, optional): Change the name of the context arugment when passing to a function. Set to \"ctx\". middleware_testing_skip_verification_key_request: (bool, optional): Skip middleware verification (NOT RECOMMENDED) \"\"\" self . _bot_token = bot_token self . _application_id = application_id if bot_token is not None : self . _registrator = RegisterCommands ( application_id = self . _application_id , bot_token = self . _bot_token ) else : self . _registrator = False self . _internal_application = FastAPI () if kwargs . get ( \"middleware_testing_skip_verification_key_request\" , False ): self . _testing_skip_verification_key_request = True else : self . _testing_skip_verification_key_request = False self . _internal_application . add_middleware ( DiscordVerificationMiddleware , client_public_key = client_public_key , testing_skip_verification_of_key = self . _testing_skip_verification_key_request , ) self . _internal_application . include_router ( router = router ) if not kwargs . get ( \"custom_context_argument_name\" ): router . _user_defined_setting_ctx_value = \"ctx\" else : router . _user_defined_setting_ctx_value = kwargs . get ( \"custom_context_argument_name\" ) self . callbacks = { \"command\" : {}, \"component\" : {}, \"message_command\" : {}, \"user_command\" : {}, } self . _cache_router = router self . _client = httpx . Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" , event_hooks = { \"response\" : [ dispike_httpx_event_hook_incoming_request ], \"request\" : [ dispike_httpx_event_hook_outgoing_request ], }, )","title":"__init__()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.async_get_all_command_permissions_in_guild","text":"Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.creating.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py async def async_get_all_command_permissions_in_guild ( self , guild_id ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" ) if _request_command_permission . status_code not in [ 200 , 201 ]: raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except DiscordAPIError : raise","title":"async_get_all_command_permissions_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.async_get_command_permission_in_guild","text":"Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py async def async_get_command_permission_in_guild ( self , command_id , guild_id ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" ) if _request_command_permission . status_code == 404 : return None elif _request_command_permission . status_code == 200 : return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) else : raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) except DiscordAPIError : logger . error ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) raise","title":"async_get_command_permission_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.async_set_command_permission","text":"Set permissions for a command in a specific guild. This function is async! Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Either a command id int or a IncomingApplicationCommand (obtained from .get_command) required guild_id int The guild to be targeted. required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool bool: True, if the command has been successfully edited. Source code in dispike/main.py async def async_set_command_permission ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set permissions for a command in a specific guild. This function is async! Args: command_id (typing.Union[int, IncomingApplicationCommand]): Either a command id int or a IncomingApplicationCommand (obtained from .get_command) guild_id (int): The guild to be targeted. new_permissions (NewApplicationPermission): Permissions for this command. Returns: bool: True, if the command has been successfully edited. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) async with httpx . AsyncClient () as client : try : _set_command_permissions = await client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , data = new_permissions . dict (), headers = self . return_bot_token_headers (), ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) return False","title":"async_set_command_permission()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.check_event_exists","text":"Checks if the event in .callbacks Parameters: Name Type Description Default event str event name required Returns: Type Description bool bool: returns if the event is in callbacks. Source code in dispike/main.py def check_event_exists ( self , event : str , type : str ) -> bool : \"\"\"Checks if the event in ``.callbacks`` Args: event (str): event name Returns: bool: returns if the event is in callbacks. \"\"\" return event in self . callbacks [ type ]","title":"check_event_exists()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.clear_all_event_callbacks","text":"Clears all event callbacks. Source code in dispike/main.py def clear_all_event_callbacks ( self , event_type : \"EventTypes\" = None ): \"\"\"Clears all event callbacks.\"\"\" if not event_type : self . callbacks = { \"command\" : {}, \"component\" : {}} else : self . callbacks [ event_type ] = {}","title":"clear_all_event_callbacks()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.delete_command","text":"Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with deleting commands from Discord\" ) def delete_command ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (typing.Union[int, IncomingApplicationCommand]): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise","title":"delete_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.edit_command","text":"Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID None new_command Union[List[dispike.creating.models.options.DiscordCommand], dispike.creating.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with editing commands from Discord\" ) def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : typing . Union [ int , IncomingApplicationCommand ] = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if command_id : if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : # TODO: Maybe don't return false and just raise it? logger . exception ( \"Discord API Failure.\" ) return False","title":"edit_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.emit","text":"'Emits' an event. It will basically call the function from .callbacks and return the function result Parameters: Name Type Description Default event str Event name required type str Event type required *args extra arguments to pass () **kwargs extra kwargs to pass {} Returns: Type Description function result returns the function result Exceptions: Type Description TypeError raises if event is not registered. Source code in dispike/main.py async def emit ( self , event : str , type : str , * args , ** kwargs ): \"\"\"'Emits' an event. It will basically call the function from .callbacks and return the function result Args: event (str): Event name type (str): Event type *args: extra arguments to pass **kwargs: extra kwargs to pass Returns: function result: returns the function result Raises: TypeError: raises if event is not registered. \"\"\" if event not in self . callbacks [ type ]: raise TypeError ( f \"event { event } does not have a corresponding handler. Did you register this function/event?\" ) _look_up_function = self . return_event_function ( event , type ) return await _look_up_function ( * args , ** kwargs )","title":"emit()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_all_command_permissions_in_guild","text":"Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.creating.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py def get_all_command_permissions_in_guild ( self , guild_id : typing . Union [ str , int ] ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" , headers = self . return_bot_token_headers (), ) if _request_command_permission . status_code not in [ 200 , 201 ]: raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except DiscordAPIError : raise","title":"get_all_command_permissions_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_command_permission_in_guild","text":"Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py def get_command_permission_in_guild ( self , command_id : typing . Union [ str , int ], guild_id : typing . Union [ str , int ] ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , headers = self . return_bot_token_headers (), ) if _request_command_permission . status_code == 404 : return None elif _request_command_permission . status_code == 200 : return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) else : raise DiscordAPIError ( status_code = _request_command_permission . status_code , request_text = _request_command_permission . text , ) except DiscordAPIError : logger . error ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) raise","title":"get_command_permission_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_commands","text":"Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.incoming.incoming_interactions.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with getting commands from Discord\" ) def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only : if not guild_id_passed or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise","title":"get_commands()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.on","text":"A wrapper over an async function, registers it in .callbacks. Parameters: Name Type Description Default event str Event name required type EventTypes Type of this event. <EventTypes.COMMAND: 'command'> func Callable function to wrap around None Returns: Type Description <function> returns the wrapped function Source code in dispike/main.py def on ( self , event : str , type : EventTypes = EventTypes . COMMAND , func : typing . Callable = None , ): \"\"\"A wrapper over an async function, registers it in .callbacks. Args: event (str): Event name type (EventTypes): Type of this event. func (None, optional): function to wrap around Returns: <function>: returns the wrapped function \"\"\" if isinstance ( type , ( EventTypes , str )): # TODO: This is broken, the only way we can show this warning is by # checking if the value is an Enum, which requires builtin-type (which we overriden) \"\"\" if not isinstance(type, EventTypes): # pragma: no cover logger.warning( \"Passing a unknown EventType, this may cause issues and is unsupported\" ) # noqa else: # TODO: Maybe it's not good to overrwrite a default python function. Maybe change type to a different value? raise InvalidEventType(type) # pragma: no cover \"\"\" else : raise InvalidEventType ( type ) def on ( func ): self . _add_function_to_callbacks ( event , type , func ) return func return on ( func ) if func else on","title":"on()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.register_collection","text":"Registers a EventCollection. Parameters: Name Type Description Default collection EventCollection The collection to register. required Source code in dispike/main.py def register_collection ( self , collection : \"EventCollection\" , register_command_with_discord : bool = False , initialze_on_load : bool = False , initialization_arguments : typing . Dict = None , ): \"\"\"Registers a EventCollection. Args: collection (EventCollection): The collection to register. \"\"\" if initialze_on_load : collection = collection ( ** initialization_arguments ) _load_in_functions = self . _detect_functions_with_event_decorator ( collection = collection , ) # TODO: Maybe re-enable this as a fallback? \"\"\" for shallow_function in collections.registered_commands(): self._add_function_to_callbacks( function=shallow_function, function_name=shallow_function._dispike_event_name, function_type=shallow_function._dispike_event_type, ) \"\"\" for shallow_function in _load_in_functions : self . _add_function_to_callbacks ( function = shallow_function , function_name = shallow_function . _dispike_event_name , function_type = shallow_function . _dispike_event_type , ) if register_command_with_discord : for command in collection . command_schemas (): if isinstance ( command , PerCommandRegistrationSettings ): self . register ( command = command . schema , guild_only = True , guild_to_target = command . guild_id , ) else : self . register ( command = command )","title":"register_collection()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.register_event_command","text":"This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Parameters: Name Type Description Default function_event_name str Function event name required function Callable Function to register. Must be async required function_type EventTypes [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. None Exceptions: Type Description AttributeError If function_type is not a string or None, and it cannot be found in the functions attributes. Source code in dispike/main.py def register_event_command ( self , function_event_name : str , function : typing . Callable , function_type : EventTypes = None , ** kwargs , ): \"\"\"This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Args: function_event_name (str): Function event name function (typing.Callable): Function to register. Must be async function_type (EventTypes): [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. Raises: AttributeError: If function_type is not a string or None, and it cannot be found in the functions attributes. \"\"\" if function_type is None : # try to see if the function has a _event_type attribute try : function_type = function . _dispike_event_type except AttributeError : raise AttributeError ( \"Unable to find function event type attribute inside function.. Did you add a decorator to this function?\" ) else : if isinstance ( function_type , EventTypes ): function_type = function_type self . _add_function_to_callbacks ( function_name = function_event_name , function_type = function_type , function = function , )","title":"register_event_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.reset_registration","text":"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Parameters: Name Type Description Default new_bot_token None Description None new_application_id None Description None Returns: Type Description TYPE bool Source code in dispike/main.py @logger . catch ( reraise = True ) def reset_registration ( self , new_bot_token = None , new_application_id = None ): \"\"\"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Args: new_bot_token (None, optional): Description new_application_id (None, optional): Description Returns: TYPE: bool \"\"\" if new_bot_token is None : _bot_token = self . _bot_token else : _bot_token = new_bot_token if new_application_id is None : _application_id = self . _application_id else : _application_id = new_application_id self . _registrator = RegisterCommands ( application_id = _application_id , bot_token = _bot_token ) self . _bot_token = _bot_token self . _application_id = _application_id return True","title":"reset_registration()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.return_event_function","text":"Returns the function registered for the event. Parameters: Name Type Description Default event str Event name required type str Event typelogger.debug(f\"logMessage\") required Exceptions: Type Description TypeError If Event name is not in callbacks. Returns: Type Description dict dict: containing func and settings Source code in dispike/main.py def return_event_function ( self , event : str , type : str ) -> dict : \"\"\"Returns the function registered for the event. Args: event (str): Event name type (str): Event typelogger.debug(f\"logMessage\") Raises: TypeError: If Event name is not in callbacks. Returns: dict: containing func and settings \"\"\" if self . check_event_exists ( event , type ): return self . callbacks [ type ][ event ][ \"function\" ] raise TypeError ( f \"Event { event } is not in callbacks. Did you register this event?\" )","title":"return_event_function()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.run","text":"Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Run the bot on a specific port. None unix_socket str [description]. Run the bot and listen on a specific unix domain socket.. None Exceptions: Type Description ArgumentError Raised if you pass both a port and a unix socket. Source code in dispike/main.py def run ( self , port : int = None , unix_socket : str = None , bind_to_ip_address : str = None , supress_insecure_binding_warning : bool = False , ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Run the bot on a specific port. unix_socket (str, optional): [description]. Run the bot and listen on a specific unix domain socket.. Raises: ArgumentError: Raised if you pass both a port and a unix socket. \"\"\" uvicorn = self . _return_uvicorn_run_function () if unix_socket and port : raise ValueError ( \"You cannot bind to port AND a unix socket\" ) else : if port : if bind_to_ip_address : if supress_insecure_binding_warning == False : warnings . warn ( \"Binding to a IP Address other than 127.0.0.1 may not be secure! If you are exposing this service to the outside world -- a reverse proxy is strongly recommended.\" , InsecureBindingWithCustomHostWarning , ) uvicorn . run ( app = self . referenced_application , host = bind_to_ip_address , port = port , ) else : uvicorn . run ( app = self . referenced_application , port = port ) elif unix_socket : if \"unix\" not in unix_socket : unix_socket = f \"unix: { unix_socket } \" else : uvicorn . run ( self . referenced_application , host = unix_socket ) if not unix_socket and not port : raise ValueError ( \"You must specify a port or unix socket\" )","title":"dispike.main.Dispike.run"},{"location":"APIRef/Dispike/#dispike.main.Dispike.send_deferred_message","text":"Send a deferred message. Parameters: Name Type Description Default original_context IncomingDiscordSlashInteraction The orginal context of the message. required new_message DiscordResponse Message to send. required Source code in dispike/main.py async def send_deferred_message ( self , original_context : \"IncomingDiscordSlashInteraction\" , new_message : \"DiscordResponse\" , ): \"\"\"Send a deferred message. Args: original_context (IncomingDiscordSlashInteraction): The orginal context of the message. new_message (DiscordResponse): Message to send. \"\"\" async with httpx . AsyncClient ( base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { original_context . token } /messages/\" , headers = { \"Content-Type\" : \"application/json\" , }, ) as client : try : # TODO: Probably change later to inside the DeferredResponse? new_message . _switch_to_followup_message () logger . debug ( f \"sending deferred response : { new_message . response } \" ) response = await client . patch ( \"/@original\" , json = new_message . response ) response . raise_for_status () except httpx . HTTPError as req : logger . exception ( f \"Unable to send deferred message!\" ) raise","title":"send_deferred_message()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.set_command_permission","text":"Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Either a command id int or a IncomingApplicationCommand (obtained from .get_command) required guild_id int The guild to be targeted. required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool bool: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_id : int , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (typing.Union[int, IncomingApplicationCommand]): Either a command id int or a IncomingApplicationCommand (obtained from .get_command) guild_id (int): The guild to be targeted. new_permissions (NewApplicationPermission): Permissions for this command. Returns: bool: True, if the command has been successfully edited. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = self . return_bot_token_headers (), ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False","title":"set_command_permission()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.view_event_function_return_type","text":"Get type hint for event functions Parameters: Name Type Description Default event str Event name required Returns: Type Description dict dict: Returns .get_type_hints for event Source code in dispike/main.py def view_event_function_return_type ( self , event : str , type : str ) -> dict : \"\"\"Get type hint for event functions Args: event (str): Event name Returns: dict: Returns .get_type_hints for event \"\"\" return typing . get_type_hints ( self . callbacks [ type ][ event ][ \"function\" ])","title":"view_event_function_return_type()"},{"location":"APIRef/EventTypes/","text":"Event Types \u00b6 Dispike comes with support for all forms of Discord Interactions. Event Name Enum Commands COMMAND Components (i.e Buttons) COMPONENT Message Commands message_command User Commands user_command You must pass an interaction type when adding the interaction decorator. By default, we will pass the EventTypes.COMMAND interaction type.","title":"Event Types"},{"location":"APIRef/EventTypes/#event-types","text":"Dispike comes with support for all forms of Discord Interactions. Event Name Enum Commands COMMAND Components (i.e Buttons) COMPONENT Message Commands message_command User Commands user_command You must pass an interaction type when adding the interaction decorator. By default, we will pass the EventTypes.COMMAND interaction type.","title":"Event Types"},{"location":"APIRef/RegCommands/","text":"\u00b6 This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async. bot_token property writable \u00b6 You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value request_headers property readonly \u00b6 Return a valid header for authorization Returns: Type Description dict a valid header for authorization __init__ ( self , application_id , bot_token ) special \u00b6 Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/creating/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" , event_hooks = { \"response\" : [ dispike_httpx_event_hook_incoming_request ], \"request\" : [ dispike_httpx_event_hook_outgoing_request ], }, ) bulk_overwrite_commands ( self , commands , guild_only = False , guild_to_target = None ) \u00b6 Bulk OVERWRITE commands to specific guilds or globally. Parameters: Name Type Description Default commands List[dispike.creating.models.options.DiscordCommand] List of new commands (these commands will be overwritten) required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py @logger . catch ( reraise = True , message = \"Issue with bulk overrwriting commands\" ) def bulk_overwrite_commands ( self , commands : typing . List [ DiscordCommand ], guild_only : bool = False , guild_to_target : int = None , ): \"\"\"Bulk OVERWRITE commands to specific guilds or globally. Args: commands (typing.List[DiscordCommand]): List of new commands (these commands will be overwritten) guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" _commands_to_json = [ command . dict ( exclude_none = True ) for command in commands ] _send_request = self . _client . put ( url = _request_url , json = _commands_to_json , headers = self . request_headers ) if _send_request . status_code == 200 : logger . info ( f \"Overwritten { len ( _send_request . json ()) } commands.. Recieved ( { len ( _commands_to_json ) } \" ) return True else : logger . debug ( f \"BULK Overwrite failed ( { guild_only } = { guild_to_target } ): Body: { _commands_to_json } .. Status code: { _send_request . status_code } \" ) raise DiscordAPIError ( _send_request . status_code , _send_request . text ) register ( self , command , guild_only = False , guild_to_target = None ) \u00b6 Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"RegisterCommands"},{"location":"APIRef/RegCommands/#dispike.creating.registrator.RegisterCommands","text":"This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async.","title":"dispike.creating.registrator.RegisterCommands"},{"location":"APIRef/RegCommands/#dispike.creating.registrator.RegisterCommands.bot_token","text":"You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value","title":"bot_token"},{"location":"APIRef/RegCommands/#dispike.creating.registrator.RegisterCommands.request_headers","text":"Return a valid header for authorization Returns: Type Description dict a valid header for authorization","title":"request_headers"},{"location":"APIRef/RegCommands/#dispike.creating.registrator.RegisterCommands.__init__","text":"Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/creating/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" , event_hooks = { \"response\" : [ dispike_httpx_event_hook_incoming_request ], \"request\" : [ dispike_httpx_event_hook_outgoing_request ], }, )","title":"__init__()"},{"location":"APIRef/RegCommands/#dispike.creating.registrator.RegisterCommands.bulk_overwrite_commands","text":"Bulk OVERWRITE commands to specific guilds or globally. Parameters: Name Type Description Default commands List[dispike.creating.models.options.DiscordCommand] List of new commands (these commands will be overwritten) required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py @logger . catch ( reraise = True , message = \"Issue with bulk overrwriting commands\" ) def bulk_overwrite_commands ( self , commands : typing . List [ DiscordCommand ], guild_only : bool = False , guild_to_target : int = None , ): \"\"\"Bulk OVERWRITE commands to specific guilds or globally. Args: commands (typing.List[DiscordCommand]): List of new commands (these commands will be overwritten) guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" _commands_to_json = [ command . dict ( exclude_none = True ) for command in commands ] _send_request = self . _client . put ( url = _request_url , json = _commands_to_json , headers = self . request_headers ) if _send_request . status_code == 200 : logger . info ( f \"Overwritten { len ( _send_request . json ()) } commands.. Recieved ( { len ( _commands_to_json ) } \" ) return True else : logger . debug ( f \"BULK Overwrite failed ( { guild_only } = { guild_to_target } ): Body: { _commands_to_json } .. Status code: { _send_request . status_code } \" ) raise DiscordAPIError ( _send_request . status_code , _send_request . text )","title":"bulk_overwrite_commands()"},{"location":"APIRef/RegCommands/#dispike.creating.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"register()"},{"location":"CreatingCommands/standard/","text":"Standard Commands \u00b6 Creating standard commands is easy to create, and follows a similar structure to building it in JSON. Dispike assists you in creating a valid JSON, and will provide auto-completion and type hints. from dispike.creating import ( DiscordCommand , CommandChoice , CommandOption , CommandTypes , ) instant_response_command = DiscordCommand ( name = \"quote\" , description = \"Return a quote from a world leader.\" , options = [ CommandOption ( name = \"worldleader\" , description = \"World leader name\" , required = True , type = CommandTypes . STRING , choices = [ CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), ], ) ], ) Above example will create a command /quote <worldleader>:{list of chocies} A list of choices will presented to the users. CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), Your handler will recieve the value of the choice. Not the name . Meaning if I chose Chancellor Angela Merkel , my bot would recieve merkel . Creating commands while preventing circular Import loops. \u00b6 Circular import loops may occur (especially when creating EventCollections, as you attempt to import on method of your ``Dispike bot, while also attempting to register the event collection). Instead of using the on method on your bot, you can from dispike import interactions @interactions . on ( ... ) async def handler ( ... ): ... Remember to register your event collection with your initialized bot otherwise your events may go unhandled.","title":"Standard Commands"},{"location":"CreatingCommands/standard/#standard-commands","text":"Creating standard commands is easy to create, and follows a similar structure to building it in JSON. Dispike assists you in creating a valid JSON, and will provide auto-completion and type hints. from dispike.creating import ( DiscordCommand , CommandChoice , CommandOption , CommandTypes , ) instant_response_command = DiscordCommand ( name = \"quote\" , description = \"Return a quote from a world leader.\" , options = [ CommandOption ( name = \"worldleader\" , description = \"World leader name\" , required = True , type = CommandTypes . STRING , choices = [ CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), ], ) ], ) Above example will create a command /quote <worldleader>:{list of chocies} A list of choices will presented to the users. CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), Your handler will recieve the value of the choice. Not the name . Meaning if I chose Chancellor Angela Merkel , my bot would recieve merkel .","title":"Standard Commands"},{"location":"CreatingCommands/standard/#creating-commands-while-preventing-circular-import-loops","text":"Circular import loops may occur (especially when creating EventCollections, as you attempt to import on method of your ``Dispike bot, while also attempting to register the event collection). Instead of using the on method on your bot, you can from dispike import interactions @interactions . on ( ... ) async def handler ( ... ): ... Remember to register your event collection with your initialized bot otherwise your events may go unhandled.","title":"Creating commands while preventing circular Import loops."},{"location":"CreatingCommands/subcommands/","text":"Subcommands \u00b6 Subcommands are a more advanced form of creating bots, and it's recommended that you read the discord documentation before coming here. Subcommands follow a similar structure as standard commands. later_response_command = DiscordCommand ( name = \"news\" , description = \"Get news!\" , options = [ CommandOption ( name = \"top\" , description = \"Get the top news.\" , type = 1 , options = [ CommandOption ( name = \"Country\" , description = \"Get news for a country!\" , type = CommandTypes . STRING , required = False , choices = [ CommandChoice ( name = \"United States\" , value = \"us\" ), CommandChoice ( name = \"Canada\" , value = \"ca\" ), CommandChoice ( name = \"Australia\" , value = \"au\" ), CommandChoice ( name = \"United Kingdom\" , value = \"gb\" ), CommandChoice ( name = \"France\" , value = \"fr\" ), CommandChoice ( name = \"South Korea\" , value = \"kr\" ), CommandChoice ( name = \"Germany\" , value = \"de\" ), ], ), ], ) ], ) Info Notice the structure, it's more \"nested\". The Discord documentation has a diagram explaining the correct structure. Above example will create /news top <country> Warning Remember to properly write your handler to account for optional arguments. [TODO: Add example code for subcommands]","title":"Subcommands"},{"location":"CreatingCommands/subcommands/#subcommands","text":"Subcommands are a more advanced form of creating bots, and it's recommended that you read the discord documentation before coming here. Subcommands follow a similar structure as standard commands. later_response_command = DiscordCommand ( name = \"news\" , description = \"Get news!\" , options = [ CommandOption ( name = \"top\" , description = \"Get the top news.\" , type = 1 , options = [ CommandOption ( name = \"Country\" , description = \"Get news for a country!\" , type = CommandTypes . STRING , required = False , choices = [ CommandChoice ( name = \"United States\" , value = \"us\" ), CommandChoice ( name = \"Canada\" , value = \"ca\" ), CommandChoice ( name = \"Australia\" , value = \"au\" ), CommandChoice ( name = \"United Kingdom\" , value = \"gb\" ), CommandChoice ( name = \"France\" , value = \"fr\" ), CommandChoice ( name = \"South Korea\" , value = \"kr\" ), CommandChoice ( name = \"Germany\" , value = \"de\" ), ], ), ], ) ], ) Info Notice the structure, it's more \"nested\". The Discord documentation has a diagram explaining the correct structure. Above example will create /news top <country> Warning Remember to properly write your handler to account for optional arguments. [TODO: Add example code for subcommands]","title":"Subcommands"},{"location":"DeletingCommands/","text":"Deleting Commands \u00b6 Deleting commands is similar to Editing Commands except the new_command parameter is not available. Simply pass the command id instead. Pair this with getting commands and you should be good to go in finding what specific commands to delete. from dispike import Dispike bot = Dispike ( ... ) bot . delete_command ( command_id = 12345 ) API Reference \u00b6 \u00b6 Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with deleting commands from Discord\" ) def delete_command ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (typing.Union[int, IncomingApplicationCommand]): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise","title":"Deleting Commands"},{"location":"DeletingCommands/#deleting-commands","text":"Deleting commands is similar to Editing Commands except the new_command parameter is not available. Simply pass the command id instead. Pair this with getting commands and you should be good to go in finding what specific commands to delete. from dispike import Dispike bot = Dispike ( ... ) bot . delete_command ( command_id = 12345 )","title":"Deleting Commands"},{"location":"DeletingCommands/#api-reference","text":"","title":"API Reference"},{"location":"DeletingCommands/#dispike.main.Dispike.delete_command","text":"Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with deleting commands from Discord\" ) def delete_command ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (typing.Union[int, IncomingApplicationCommand]): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise","title":"dispike.main.Dispike.delete_command"},{"location":"DeployingToProduction/DeployingToServerless/","text":"Deploying to 'Serverless' platforms. \u00b6 Since dispike is a normal AGSI application under the hood, you should have no compatibility issues using 'serverless' platforms such as Amazon Lambda (using an adapter such as magnum ) Google Cloud App Engine (flex and standard environements) Vercel Heroku Configuration and documentation can be found all over the internet (Search for FastAPI).. Reminder \u00b6 AGSI entry point is hosted under .referenced_application attribute for your main bot. You may need to instruct Dispike to bind to 0.0.0.0! Deploying to AWS Lambda \u00b6 Resources \u00b6 https://towardsdatascience.com/fastapi-aws-robust-api-part-1-f67ae47390f9 https://github.com/iwpnd/fastapi-aws-lambda-example Deploying to Google Cloud App Engine \u00b6 Resources \u00b6 https://medium.com/analytics-vidhya/deploying-fastapi-application-in-google-app-engine-in-standard-environment-dc061d3277a https://github.com/tiangolo/fastapi/issues/228 Deploying to Vercel \u00b6 Resources \u00b6 https://blog.logrocket.com/deploying-fastapi-applications-to-vercel/ https://github.com/benfasoli/vercel-fastapi Deploying to Heroku \u00b6 https://towardsdatascience.com/how-to-deploy-your-fastapi-app-on-heroku-for-free-8d4271a4ab9 https://towardsdatascience.com/autodeploy-fastapi-app-to-heroku-via-git-in-these-5-easy-steps-8c7958ef5d41 https://github.com/ms7m/dispike/pull/35#issue-607374151","title":"Deploying to 'Serverless'"},{"location":"DeployingToProduction/DeployingToServerless/#deploying-to-serverless-platforms","text":"Since dispike is a normal AGSI application under the hood, you should have no compatibility issues using 'serverless' platforms such as Amazon Lambda (using an adapter such as magnum ) Google Cloud App Engine (flex and standard environements) Vercel Heroku Configuration and documentation can be found all over the internet (Search for FastAPI)..","title":"Deploying to 'Serverless' platforms."},{"location":"DeployingToProduction/DeployingToServerless/#reminder","text":"AGSI entry point is hosted under .referenced_application attribute for your main bot. You may need to instruct Dispike to bind to 0.0.0.0!","title":"Reminder"},{"location":"DeployingToProduction/DeployingToServerless/#deploying-to-aws-lambda","text":"","title":"Deploying to AWS Lambda"},{"location":"DeployingToProduction/DeployingToServerless/#resources","text":"https://towardsdatascience.com/fastapi-aws-robust-api-part-1-f67ae47390f9 https://github.com/iwpnd/fastapi-aws-lambda-example","title":"Resources"},{"location":"DeployingToProduction/DeployingToServerless/#deploying-to-google-cloud-app-engine","text":"","title":"Deploying to Google Cloud App Engine"},{"location":"DeployingToProduction/DeployingToServerless/#resources_1","text":"https://medium.com/analytics-vidhya/deploying-fastapi-application-in-google-app-engine-in-standard-environment-dc061d3277a https://github.com/tiangolo/fastapi/issues/228","title":"Resources"},{"location":"DeployingToProduction/DeployingToServerless/#deploying-to-vercel","text":"","title":"Deploying to Vercel"},{"location":"DeployingToProduction/DeployingToServerless/#resources_2","text":"https://blog.logrocket.com/deploying-fastapi-applications-to-vercel/ https://github.com/benfasoli/vercel-fastapi","title":"Resources"},{"location":"DeployingToProduction/DeployingToServerless/#deploying-to-heroku","text":"https://towardsdatascience.com/how-to-deploy-your-fastapi-app-on-heroku-for-free-8d4271a4ab9 https://towardsdatascience.com/autodeploy-fastapi-app-to-heroku-via-git-in-these-5-easy-steps-8c7958ef5d41 https://github.com/ms7m/dispike/pull/35#issue-607374151","title":"Deploying to Heroku"},{"location":"DeployingToProduction/DeployingWithReverseProxy/","text":"Deploying with Reverse Proxy. \u00b6 There may be some example configurations for your reverse proxy available here . Creating your configuration (Nginx) \u00b6 Configure a process manager \u00b6 Configuring a process manager is recommended, as it can allow you to Automatically restart if the bot goes down Run the bot in the background There are a number of process managers available such as: Supervisord PM2 Run the bot with Uvicorn and bind to a UNIX socket. \u00b6 $ uvicorn file_containing_bot:bot.referenced_application --bind = unix:/tmp/dispike.sock <span style=\"color: green;\">INFO</span>: Uvicorn running on unix:/tmp/dispike.sock (Press CTRL+C to quit) Info Unix sockets are often twice as fast compared to using TCP ports . Dispike allows you to bind to a local port (without binding to 0.0.0.0). Create your Nginx configuration. (This is a sample) \u00b6 worker_processes 1 ; user nobody nogroup ; # 'user nobody nobody;' for systems with 'nobody' as a group instead error_log /var/log/nginx/error.log warn ; pid /var/run/nginx.pid ; events { worker_connections 1024 ; # increase if you have lots of clients accept_mutex off ; # set to 'on' if nginx worker_processes > 1 # 'use epoll;' to enable for Linux 2.6+ # 'use kqueue;' to enable for FreeBSD, OSX } http { include mime.types ; # fallback in case we can't determine a type default_type application/octet-stream ; access_log /var/log/nginx/access.log combined ; sendfile on ; upstream dispike { # fail_timeout=0 means we always retry an upstream even if it failed # to return a good HTTP response # for UNIX domain socket setups server unix:/tmp/dispike.sock fail_timeout=0 ; # for a TCP configuration # server 192.168.0.7:8000 fail_timeout=0; } server { # if no Host match, close the connection to prevent host spoofing listen 80 default_server ; return 444 ; } server { # use 'listen 80 deferred;' for Linux # use 'listen 80 accept_filter=httpready;' for FreeBSD listen 443 ; client_max_body_size 4G ; ssl_certificate /path/to/ssl/certificate ; ssl_certificate_key /path/to/ssl/certificate/key ; # set the correct host(s) for your site server_name example.com www.example.com ; keepalive_timeout 5 ; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_set_header X-Forwarded-Proto $scheme ; proxy_set_header Host $http_host ; # we don't want nginx trying to do something clever with # redirects, we set the Host: header above already. proxy_redirect off ; proxy_pass http://dispike ; } } } If this doesn't work for you.. DigitalOcean provides a tool to help you create a Nginx Configuration. Info We have a WIP repository containing sample configurations for different proxies. Check it out here Resources \u00b6 Here are some resources to help you create configurations for your favorite reverse proxy server. https://fastapi.tiangolo.com/advanced/behind-a-proxy/ Caddy 2 Reverse Proxy Caddy offers a functionality to automatically provision SSL certificates. Once you are completed, start your proxy, configure DNS, and check if it's working by visiting https://your-server.com/ping .","title":"Deploying with a Reverse Proxy"},{"location":"DeployingToProduction/DeployingWithReverseProxy/#deploying-with-reverse-proxy","text":"There may be some example configurations for your reverse proxy available here .","title":"Deploying with Reverse Proxy."},{"location":"DeployingToProduction/DeployingWithReverseProxy/#creating-your-configuration-nginx","text":"","title":"Creating your configuration (Nginx)"},{"location":"DeployingToProduction/DeployingWithReverseProxy/#configure-a-process-manager","text":"Configuring a process manager is recommended, as it can allow you to Automatically restart if the bot goes down Run the bot in the background There are a number of process managers available such as: Supervisord PM2","title":"Configure a process manager"},{"location":"DeployingToProduction/DeployingWithReverseProxy/#run-the-bot-with-uvicorn-and-bind-to-a-unix-socket","text":"$ uvicorn file_containing_bot:bot.referenced_application --bind = unix:/tmp/dispike.sock <span style=\"color: green;\">INFO</span>: Uvicorn running on unix:/tmp/dispike.sock (Press CTRL+C to quit) Info Unix sockets are often twice as fast compared to using TCP ports . Dispike allows you to bind to a local port (without binding to 0.0.0.0).","title":"Run the bot with Uvicorn and bind to a UNIX socket."},{"location":"DeployingToProduction/DeployingWithReverseProxy/#create-your-nginx-configuration-this-is-a-sample","text":"worker_processes 1 ; user nobody nogroup ; # 'user nobody nobody;' for systems with 'nobody' as a group instead error_log /var/log/nginx/error.log warn ; pid /var/run/nginx.pid ; events { worker_connections 1024 ; # increase if you have lots of clients accept_mutex off ; # set to 'on' if nginx worker_processes > 1 # 'use epoll;' to enable for Linux 2.6+ # 'use kqueue;' to enable for FreeBSD, OSX } http { include mime.types ; # fallback in case we can't determine a type default_type application/octet-stream ; access_log /var/log/nginx/access.log combined ; sendfile on ; upstream dispike { # fail_timeout=0 means we always retry an upstream even if it failed # to return a good HTTP response # for UNIX domain socket setups server unix:/tmp/dispike.sock fail_timeout=0 ; # for a TCP configuration # server 192.168.0.7:8000 fail_timeout=0; } server { # if no Host match, close the connection to prevent host spoofing listen 80 default_server ; return 444 ; } server { # use 'listen 80 deferred;' for Linux # use 'listen 80 accept_filter=httpready;' for FreeBSD listen 443 ; client_max_body_size 4G ; ssl_certificate /path/to/ssl/certificate ; ssl_certificate_key /path/to/ssl/certificate/key ; # set the correct host(s) for your site server_name example.com www.example.com ; keepalive_timeout 5 ; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_set_header X-Forwarded-Proto $scheme ; proxy_set_header Host $http_host ; # we don't want nginx trying to do something clever with # redirects, we set the Host: header above already. proxy_redirect off ; proxy_pass http://dispike ; } } } If this doesn't work for you.. DigitalOcean provides a tool to help you create a Nginx Configuration. Info We have a WIP repository containing sample configurations for different proxies. Check it out here","title":"Create your Nginx configuration. (This is a sample)"},{"location":"DeployingToProduction/DeployingWithReverseProxy/#resources","text":"Here are some resources to help you create configurations for your favorite reverse proxy server. https://fastapi.tiangolo.com/advanced/behind-a-proxy/ Caddy 2 Reverse Proxy Caddy offers a functionality to automatically provision SSL certificates. Once you are completed, start your proxy, configure DNS, and check if it's working by visiting https://your-server.com/ping .","title":"Resources"},{"location":"DeployingToProduction/DeployingWithoutServer/","text":"Deploying Without A Reverse Proxy Server \u00b6 Warning This is not recommended unless your cloud provider/deployment service provides this already. Sample Bot File \u00b6 from dispike import Dispike bot = Dispike ( ... ) Running directly from the bot. \u00b6 from dispike import Dispike bot = Dispike ( ... ) # Bind port to something higher if you run into problems with root. bot . run ( bind_to_ip_address = \"0.0.0.0\" , port = 443 ) Running bot with Uvicorn \u00b6 Installing Uvicorn \u00b6 $ pip install uvicorn [ standard ] ---> 100% Running the bot on a specific port + allowing outside connections. \u00b6 $ uvicorn file_containing_bot:bot.referenced_application --host 0 .0.0.0 --port 444 --ssl-keyfile = ./key.pem --ssl-certfile = ./cert.pem <span style=\"color: green;\">INFO</span>: Uvicorn running on http://0.0.0.0:443 (Press CTRL+C to quit) .referenced_application is extremely important. You may want to read Uvicorn's documentation for more keyword arguments or to deploy with Gunicorn instead. Running bot with Hypercorn \u00b6 $ pip install hypercorn ---> 100% Running the bot on a specific port + allowing outside connections. \u00b6 $ hypercorn file_containing_bot:bot.referenced_application --bind 0 .0.0.0:443 Running on 0.0.0.0:8080 over http (CTRL + C to quit) .referenced_application is extremely important.","title":"Deploying without a Server"},{"location":"DeployingToProduction/DeployingWithoutServer/#deploying-without-a-reverse-proxy-server","text":"Warning This is not recommended unless your cloud provider/deployment service provides this already.","title":"Deploying Without A Reverse Proxy Server"},{"location":"DeployingToProduction/DeployingWithoutServer/#sample-bot-file","text":"from dispike import Dispike bot = Dispike ( ... )","title":"Sample Bot File"},{"location":"DeployingToProduction/DeployingWithoutServer/#running-directly-from-the-bot","text":"from dispike import Dispike bot = Dispike ( ... ) # Bind port to something higher if you run into problems with root. bot . run ( bind_to_ip_address = \"0.0.0.0\" , port = 443 )","title":"Running directly from the bot."},{"location":"DeployingToProduction/DeployingWithoutServer/#running-bot-with-uvicorn","text":"","title":"Running bot with Uvicorn"},{"location":"DeployingToProduction/DeployingWithoutServer/#installing-uvicorn","text":"$ pip install uvicorn [ standard ] ---> 100%","title":"Installing Uvicorn"},{"location":"DeployingToProduction/DeployingWithoutServer/#running-the-bot-on-a-specific-port-allowing-outside-connections","text":"$ uvicorn file_containing_bot:bot.referenced_application --host 0 .0.0.0 --port 444 --ssl-keyfile = ./key.pem --ssl-certfile = ./cert.pem <span style=\"color: green;\">INFO</span>: Uvicorn running on http://0.0.0.0:443 (Press CTRL+C to quit) .referenced_application is extremely important. You may want to read Uvicorn's documentation for more keyword arguments or to deploy with Gunicorn instead.","title":"Running the bot on a specific port + allowing outside connections."},{"location":"DeployingToProduction/DeployingWithoutServer/#running-bot-with-hypercorn","text":"$ pip install hypercorn ---> 100%","title":"Running bot with Hypercorn"},{"location":"DeployingToProduction/DeployingWithoutServer/#running-the-bot-on-a-specific-port-allowing-outside-connections_1","text":"$ hypercorn file_containing_bot:bot.referenced_application --bind 0 .0.0.0:443 Running on 0.0.0.0:8080 over http (CTRL + C to quit) .referenced_application is extremely important.","title":"Running the bot on a specific port + allowing outside connections."},{"location":"EditingCommands/","text":"Editing Commands \u00b6 Editing commands require an already initialized Dispike instance and are available as a method provided by Dispike . Bulk editing is available by setting the bulk parameter to True and passing a list of DiscordCommand to the new_command parameter. Editing a single command can be done by passing a DiscordCommand to new_command and specifying the target command ID. Guild-level editing command is available by configuring parameters guild_only -> True guild_id_passed -> GUILD ID Info Follow this Discord guide to find your server/guild ID from dispike import Dispike from dispike.creating import ( DiscordCommand ) bot = Dispike ( ... ) bot . edit_command ( new_command = DiscordCommand ( ... ), command_id = 12345 ) from dispike import Dispike from dispike.creating.models import DiscordCommand bot = Dispike ( ... ) edit_bulk_commands = [ DiscordCommand ( ... ), DiscordCommand ( ... )] bot . edit_command ( new_command = edit_bulk_commands , bulk = True ) API Reference \u00b6 \u00b6 Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID None new_command Union[List[dispike.creating.models.options.DiscordCommand], dispike.creating.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with editing commands from Discord\" ) def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : typing . Union [ int , IncomingApplicationCommand ] = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if command_id : if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : # TODO: Maybe don't return false and just raise it? logger . exception ( \"Discord API Failure.\" ) return False Handling Permissions \u00b6 Permissions are a new feature in Discord that allow bot developers to add permissions for a command. Dispike can help you - View permissions for a command in a guild. - Craft the correct syntax for setting a permission (or multiple) for a command. Preface \u00b6 It's helpful that you read the documentation for Discord to understand how to craft permissions. . Not reading the documentation may result in you creating dangerous commands for a server! Getting Started \u00b6 Import the following: from dispike.creating.models.permissions import ( ApplicationCommandPermissions , NewApplicationPermission , ApplicationCommandPermissionType , ) Sample Code \u00b6 new_permission = NewApplicationPermission ( permissions = [ ApplicationCommandPermissions ( id = \"<Discord User Id>\" , type = ApplicationCommandPermissionType . USER , permission = True , # Whether to determine if the user has permission. ) ] ) get_commands = bot . get_commands ( guild_only = True , guild_id_passed = \"<Guild ID>\" ) selected_command = get_commands [ 0 ] update_permission_for_command = bot . set_command_permission ( command_id = selected_command . id # also can be passed manually guild_id = \"<Guild ID>\" , new_permission ) print ( update_permission_for_command ) >> True The example above starts out with creating a new command using NewApplicationPermission . If you read the documentation, it should look familiar to the example provided by Discord -- except for the type that is passed. You can manually use a normal int value for type parameter, otherwise you can use a helper class called ApplicationCommandPermissionType . \u00b6 The permission type of the Application Command. Info \u200b Remember -- You are able to have multiple permissions as the permissions parameter is a List . However you should note Discord's docs about how certain permissions may conflict and throw an error. In a future version dispike may alert you of offending permissions, but for now keep in mind. Afterwards, we need a command to edit, we check this by gathering every command in a guild. If you are not familiar with this, you can read more here . There is a function available in the bot instance that will allow you to update a commands permission. This function is also available in sync & async. \u00b6 Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Either a command id int or a IncomingApplicationCommand (obtained from .get_command) required guild_id int The guild to be targeted. required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool bool: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_id : int , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (typing.Union[int, IncomingApplicationCommand]): Either a command id int or a IncomingApplicationCommand (obtained from .get_command) guild_id (int): The guild to be targeted. new_permissions (NewApplicationPermission): Permissions for this command. Returns: bool: True, if the command has been successfully edited. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = self . return_bot_token_headers (), ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False Overwriting Commands \u00b6 If you prefer to overwrite an existing commands, you can","title":"Editing Commands"},{"location":"EditingCommands/#editing-commands","text":"Editing commands require an already initialized Dispike instance and are available as a method provided by Dispike . Bulk editing is available by setting the bulk parameter to True and passing a list of DiscordCommand to the new_command parameter. Editing a single command can be done by passing a DiscordCommand to new_command and specifying the target command ID. Guild-level editing command is available by configuring parameters guild_only -> True guild_id_passed -> GUILD ID Info Follow this Discord guide to find your server/guild ID from dispike import Dispike from dispike.creating import ( DiscordCommand ) bot = Dispike ( ... ) bot . edit_command ( new_command = DiscordCommand ( ... ), command_id = 12345 ) from dispike import Dispike from dispike.creating.models import DiscordCommand bot = Dispike ( ... ) edit_bulk_commands = [ DiscordCommand ( ... ), DiscordCommand ( ... )] bot . edit_command ( new_command = edit_bulk_commands , bulk = True )","title":"Editing Commands"},{"location":"EditingCommands/#api-reference","text":"","title":"API Reference"},{"location":"EditingCommands/#dispike.main.Dispike.edit_command","text":"Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Command ID None new_command Union[List[dispike.creating.models.options.DiscordCommand], dispike.creating.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with editing commands from Discord\" ) def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : typing . Union [ int , IncomingApplicationCommand ] = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if command_id : if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only : if not guild_id_passed : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : # TODO: Maybe don't return false and just raise it? logger . exception ( \"Discord API Failure.\" ) return False","title":"dispike.main.Dispike.edit_command"},{"location":"EditingCommands/#handling-permissions","text":"Permissions are a new feature in Discord that allow bot developers to add permissions for a command. Dispike can help you - View permissions for a command in a guild. - Craft the correct syntax for setting a permission (or multiple) for a command.","title":"Handling Permissions"},{"location":"EditingCommands/#preface","text":"It's helpful that you read the documentation for Discord to understand how to craft permissions. . Not reading the documentation may result in you creating dangerous commands for a server!","title":"Preface"},{"location":"EditingCommands/#getting-started","text":"Import the following: from dispike.creating.models.permissions import ( ApplicationCommandPermissions , NewApplicationPermission , ApplicationCommandPermissionType , )","title":"Getting Started"},{"location":"EditingCommands/#sample-code","text":"new_permission = NewApplicationPermission ( permissions = [ ApplicationCommandPermissions ( id = \"<Discord User Id>\" , type = ApplicationCommandPermissionType . USER , permission = True , # Whether to determine if the user has permission. ) ] ) get_commands = bot . get_commands ( guild_only = True , guild_id_passed = \"<Guild ID>\" ) selected_command = get_commands [ 0 ] update_permission_for_command = bot . set_command_permission ( command_id = selected_command . id # also can be passed manually guild_id = \"<Guild ID>\" , new_permission ) print ( update_permission_for_command ) >> True The example above starts out with creating a new command using NewApplicationPermission . If you read the documentation, it should look familiar to the example provided by Discord -- except for the type that is passed. You can manually use a normal int value for type parameter, otherwise you can use a helper class called ApplicationCommandPermissionType .","title":"Sample Code"},{"location":"EditingCommands/#dispike.creating.models.permissions.ApplicationCommandPermissionType","text":"The permission type of the Application Command. Info \u200b Remember -- You are able to have multiple permissions as the permissions parameter is a List . However you should note Discord's docs about how certain permissions may conflict and throw an error. In a future version dispike may alert you of offending permissions, but for now keep in mind. Afterwards, we need a command to edit, we check this by gathering every command in a guild. If you are not familiar with this, you can read more here . There is a function available in the bot instance that will allow you to update a commands permission. This function is also available in sync & async.","title":"dispike.creating.models.permissions.ApplicationCommandPermissionType"},{"location":"EditingCommands/#dispike.main.Dispike.set_command_permission","text":"Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id Union[int, dispike.incoming.incoming_interactions.IncomingApplicationCommand] Either a command id int or a IncomingApplicationCommand (obtained from .get_command) required guild_id int The guild to be targeted. required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool bool: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id : typing . Union [ int , IncomingApplicationCommand ], guild_id : int , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (typing.Union[int, IncomingApplicationCommand]): Either a command id int or a IncomingApplicationCommand (obtained from .get_command) guild_id (int): The guild to be targeted. new_permissions (NewApplicationPermission): Permissions for this command. Returns: bool: True, if the command has been successfully edited. \"\"\" if isinstance ( command_id , IncomingApplicationCommand ): command_id = command_id . id elif isinstance ( command_id , ( str , int )): command_id = int ( command_id ) else : raise TypeError ( \"The command ID must be either an interger or an IncomingApplicationCommand object.\" ) with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = self . return_bot_token_headers (), ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False","title":"dispike.main.Dispike.set_command_permission"},{"location":"EditingCommands/#overwriting-commands","text":"If you prefer to overwrite an existing commands, you can","title":"Overwriting Commands"},{"location":"GettingCommands/","text":"Getting Commands \u00b6 Retrieving existing commands require an already initialized Dispike object. You can specify whether to return commands globally or per guild. Getting commands is similar to Editing Commands except for new_command , command_id , parameters are not available. from dispike import Dispike bot = Dispike ( ... ) commands = bot . get_commands () >>> [ IncomingApplicationCommand ( ... ), IncomingApplicationCommand ( ... )] API Reference \u00b6 \u00b6 Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.incoming.incoming_interactions.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with getting commands from Discord\" ) def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only : if not guild_id_passed or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise","title":"Getting Commands"},{"location":"GettingCommands/#getting-commands","text":"Retrieving existing commands require an already initialized Dispike object. You can specify whether to return commands globally or per guild. Getting commands is similar to Editing Commands except for new_command , command_id , parameters are not available. from dispike import Dispike bot = Dispike ( ... ) commands = bot . get_commands () >>> [ IncomingApplicationCommand ( ... ), IncomingApplicationCommand ( ... )]","title":"Getting Commands"},{"location":"GettingCommands/#api-reference","text":"","title":"API Reference"},{"location":"GettingCommands/#dispike.main.Dispike.get_commands","text":"Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.incoming.incoming_interactions.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py @logger . catch ( reraise = True , message = \"Issue with getting commands from Discord\" ) def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only : if not guild_id_passed or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise","title":"dispike.main.Dispike.get_commands"},{"location":"MigrationGuide/MigrationGuide/","text":"Migration Guide (<1.0.0b) \u00b6 v1.0.0b introduced a large number of breaking changes. Renamed dispike.register to dispike.creating . Moved allow_mentions file from dispike.models to dispike.creating Moved components from dispike.helper to dispike.creating Renamed dispike.models to dispike.incoming Renamed incoming in dispike.incoming to incoming_interactions bot.interactions.on has been deprecated. Please use bot.on instead or dispike.interactions.on . EventHandler class has been removed, most of the functions have been implemented inside Dispike The following commands now will raise an DiscordAPIError if the Discord API returns an unexpected status code. set_command_permission async_set_command_permission async_get_command_permission_in_guild async_get_all_command_permissions_in_guild get_all_command_permissions_in_guild get_command_permission_in_guild Bot Tokens are no longer required to initialize a Dispike object.. Accessing methods, attributes or functions that require a bot token (such as registering commands) will now raise a new exception: dispike.errors.dispike.BotTokenNotProvided . Certain features are still available without a bot token. Such as sending deferred messages or just responding to interactions. (closes #51) DiscordResponse will now raise an exception dispike.errors.responses.InvalidDiscordResponse for certain combinations of values. (closes #50) Added default_permission to DiscordCommand .. Learn more here . This value is set to True by default. (closes #53) Accessing methods such as .lookup_resolved_channel in IncomingDiscordInteraction with no resolved structures will now raise dispike.errors.response.NoResolvedInteractions . CommandTypes has been changed to OptionTypes . A new class of actual command types has been added. IncomingDiscordOptionList changed to IncomingDiscordSlashData to better match what it actually is. IncomingDiscordInteraction changed to IncomingDiscordSlashInteraction DiscordCommand now takes a type which defaults to CommandTypes.SLASH (AKA Type 1) DiscordCommand now validates that slash commands contain a description. DiscordCommand now validates that context commands (Currently only MESSAGE , USER ) do not have a description or options. New events: MESSAGE_COMMAND USER_COMMAND New WIP classes Message and MessageAttachment . Discord says they will add attachments as a option type in the future. New IncomingInteraction ctx classes IncomingDiscordUserCommandInteraction and IncomingDiscordMessageCommandInteraction","title":"Migration from <1.0.0b"},{"location":"MigrationGuide/MigrationGuide/#migration-guide-100b","text":"v1.0.0b introduced a large number of breaking changes. Renamed dispike.register to dispike.creating . Moved allow_mentions file from dispike.models to dispike.creating Moved components from dispike.helper to dispike.creating Renamed dispike.models to dispike.incoming Renamed incoming in dispike.incoming to incoming_interactions bot.interactions.on has been deprecated. Please use bot.on instead or dispike.interactions.on . EventHandler class has been removed, most of the functions have been implemented inside Dispike The following commands now will raise an DiscordAPIError if the Discord API returns an unexpected status code. set_command_permission async_set_command_permission async_get_command_permission_in_guild async_get_all_command_permissions_in_guild get_all_command_permissions_in_guild get_command_permission_in_guild Bot Tokens are no longer required to initialize a Dispike object.. Accessing methods, attributes or functions that require a bot token (such as registering commands) will now raise a new exception: dispike.errors.dispike.BotTokenNotProvided . Certain features are still available without a bot token. Such as sending deferred messages or just responding to interactions. (closes #51) DiscordResponse will now raise an exception dispike.errors.responses.InvalidDiscordResponse for certain combinations of values. (closes #50) Added default_permission to DiscordCommand .. Learn more here . This value is set to True by default. (closes #53) Accessing methods such as .lookup_resolved_channel in IncomingDiscordInteraction with no resolved structures will now raise dispike.errors.response.NoResolvedInteractions . CommandTypes has been changed to OptionTypes . A new class of actual command types has been added. IncomingDiscordOptionList changed to IncomingDiscordSlashData to better match what it actually is. IncomingDiscordInteraction changed to IncomingDiscordSlashInteraction DiscordCommand now takes a type which defaults to CommandTypes.SLASH (AKA Type 1) DiscordCommand now validates that slash commands contain a description. DiscordCommand now validates that context commands (Currently only MESSAGE , USER ) do not have a description or options. New events: MESSAGE_COMMAND USER_COMMAND New WIP classes Message and MessageAttachment . Discord says they will add attachments as a option type in the future. New IncomingInteraction ctx classes IncomingDiscordUserCommandInteraction and IncomingDiscordMessageCommandInteraction","title":"Migration Guide (&lt;1.0.0b)"},{"location":"Models/","text":"Models \u00b6 Models are responses or requests to and from Discord that have been verified. Data can be accessed in a pythonic way of attributes rather than dictionaries. Info If you want a more low-level or want to transport models (pickling) you can access attributes .to_dict or .to_json . Models have been split into sections. - Incoming - Outgoing Outgoing models are usually created by the user and meant to be sent to Discord, and have the strictest validation. They are easily editable by property. Incoming models are usually models that have been translated from Discord themselves and have been validated. While it's possible to edit the attributes, no function provided by Dispike will accept them. Treat them as read-only. Info in certain circumstances, you can convert Incoming models to Outgoing, simply pass .to_dict of the incoming object to the appropriate outgoing object by doing OutgoingObject(**IncomingObject) .","title":"Info"},{"location":"Models/#models","text":"Models are responses or requests to and from Discord that have been verified. Data can be accessed in a pythonic way of attributes rather than dictionaries. Info If you want a more low-level or want to transport models (pickling) you can access attributes .to_dict or .to_json . Models have been split into sections. - Incoming - Outgoing Outgoing models are usually created by the user and meant to be sent to Discord, and have the strictest validation. They are easily editable by property. Incoming models are usually models that have been translated from Discord themselves and have been validated. While it's possible to edit the attributes, no function provided by Dispike will accept them. Treat them as read-only. Info in certain circumstances, you can convert Incoming models to Outgoing, simply pass .to_dict of the incoming object to the appropriate outgoing object by doing OutgoingObject(**IncomingObject) .","title":"Models"},{"location":"Models/Incoming/","text":"Incoming Objects \u00b6 IncomingDiscordInteraction is a helper object that is passed to every handler argument ( ctx ). It allows you to view context from the command/button/menu from where it was sent and by who. It's recommended to read the Discord documentation to learn more about what data is returned. Info If you want to change the keyword argument name in where the context will be passed to, you can pass custom_context_argument_name to Dispike . \u00b6 attribute_helpers special \u00b6 resolved_interactions \u00b6 resolved_interactions_finder ( cls , query , type_to_determine ) \u00b6 Finds all interactions that are resolved. :param query: The query to search for. :param type_to_determine: The type of interaction to search for. :return: A list of all interactions that are resolved. Source code in dispike/incoming/attribute_helpers/resolved_interactions.py @logger . catch ( reraise = True , message = \"Unable to lookup query for resolve\" ) def resolved_interactions_finder ( cls : \"IncomingDiscordSlashInteraction\" , query : typing . Union [ str , int ], type_to_determine : str , ) -> typing . Union [ PartialMember , None ]: \"\"\" Finds all interactions that are resolved. :param query: The query to search for. :param type_to_determine: The type of interaction to search for. :return: A list of all interactions that are resolved. \"\"\" _grab_member = cls . data . resolved [ type_to_determine ] . get ( query , None ) if _grab_member is not None : return _class_return [ type_to_determine ]( ** _grab_member ) return _grab_member discord_types special \u00b6 channel \u00b6 ChannelTypes \u00b6 An enumeration. PartialChannel pydantic-model \u00b6 A partial representation for a discord channel. This is found in a Application Command Interaction Data Resolved Structure Partial Channel objects only have id, name, type and permissions attributes. member \u00b6 Member pydantic-model \u00b6 A representation of a discord member, intended for you to easily access attributes. this is not intended for you to edit, and will not be accepted as an argument in any function. PartialMember pydantic-model \u00b6 A partial representation for a discord user. This is found in a Application Command Interaction Data Resolved Structure Partial Member objects are missing user, deaf and mute attributes. message \u00b6 Message pydantic-model \u00b6 A representation of a discord message, intended for you to easily access attributes. this is not intended for you to edit, and will not be accepted as an argument in any function. MessageAttachment pydantic-model \u00b6 A message attachment user \u00b6 User pydantic-model \u00b6 A representation of a User object from discord. this is not intended for you to edit, and will not be accepted as an argument in any function. incoming_interactions \u00b6 IncomingApplicationCommand pydantic-model \u00b6 An Incoming Application command, this is not intended for you to edit, and will not be accepted in any function Attributes: Name Type Description id int Id of the interaction. application_id int The id of your bot. name int Name of the command. description int Description of the command. options Union[List[CommandOption], List[SubcommandOption]] Selected options from the command. default_permission bool Bool whether if uses default permissions. IncomingDiscordButtonData pydantic-model \u00b6 Incoming button data. Attributes: Name Type Description custom_id str The custom id of this button. IncomingDiscordButtonInteraction pydantic-model \u00b6 An incoming discord interaction that was triggered by a button press, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordButtonData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member TODO: IDK if this is the member that called the command originally or the one that used the button. token str Token of this interaction. IncomingDiscordMessageCommandData pydantic-model \u00b6 Incoming message command data. Attributes: Name Type Description target_id str The id of the targeted message. target Message The target message. name str The name of the message command. IncomingDiscordMessageCommandInteraction pydantic-model \u00b6 An incoming discord interaction that was triggered by a message command interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordMessageCommandData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member Member that called the command. token str Token of this interaction. IncomingDiscordOption pydantic-model \u00b6 An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand Attributes: Name Type Description name str Name of the option value str Value of the option IncomingDiscordSelectMenuData pydantic-model \u00b6 Incoming select menu data. Attributes: Name Type Description custom_id str The custom id of this button. values List[str] A list of string values that the user selected. IncomingDiscordSelectMenuInteraction pydantic-model \u00b6 An incoming discord interaction that was triggered by a select menu interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordSelectMenuData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member TODO: IDK if this is the member that called the command originally or the one that used the select menu. token str Token of this interaction. IncomingDiscordSlashData pydantic-model \u00b6 An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand Attributes: Name Type Description id str Id of the command name str Name of the command options Union[List[IncomingDiscordOption], List[SubcommandIncomingDiscordOptionList]] Options selected by the user IncomingDiscordSlashInteraction pydantic-model \u00b6 An incoming discord interaction that was triggered by a command, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordSlashData Options from the command. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member Member that used this interaction. token str Token of this interaction. IncomingDiscordUserCommandData pydantic-model \u00b6 Incoming user command data. Attributes: Name Type Description target_id str The id of the targeted user. target Member The targeted member. name str The name of the user command. IncomingDiscordUserCommandInteraction pydantic-model \u00b6 An incoming discord interaction that was triggered by a user command interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordUserCommandData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member Member that called the command. token str Token of this interaction. SubcommandIncomingDiscordOptionList pydantic-model \u00b6 An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand Attributes: Name Type Description name str Name of the subcommand options Union[List[IncomingDiscordOption], List[SubcommandIncomingDiscordOptionListChild]] Options selected by the user SubcommandIncomingDiscordOptionListChild pydantic-model \u00b6 Attributes: Name Type Description name str Name of the subcommand options List[IncomingDiscordOption]] Options selected by the user","title":"Incoming"},{"location":"Models/Incoming/#incoming-objects","text":"IncomingDiscordInteraction is a helper object that is passed to every handler argument ( ctx ). It allows you to view context from the command/button/menu from where it was sent and by who. It's recommended to read the Discord documentation to learn more about what data is returned. Info If you want to change the keyword argument name in where the context will be passed to, you can pass custom_context_argument_name to Dispike .","title":"Incoming Objects"},{"location":"Models/Incoming/#dispike.incoming","text":"","title":"dispike.incoming"},{"location":"Models/Incoming/#dispike.incoming.attribute_helpers","text":"","title":"attribute_helpers"},{"location":"Models/Incoming/#dispike.incoming.attribute_helpers.resolved_interactions","text":"","title":"resolved_interactions"},{"location":"Models/Incoming/#dispike.incoming.attribute_helpers.resolved_interactions.resolved_interactions_finder","text":"Finds all interactions that are resolved. :param query: The query to search for. :param type_to_determine: The type of interaction to search for. :return: A list of all interactions that are resolved. Source code in dispike/incoming/attribute_helpers/resolved_interactions.py @logger . catch ( reraise = True , message = \"Unable to lookup query for resolve\" ) def resolved_interactions_finder ( cls : \"IncomingDiscordSlashInteraction\" , query : typing . Union [ str , int ], type_to_determine : str , ) -> typing . Union [ PartialMember , None ]: \"\"\" Finds all interactions that are resolved. :param query: The query to search for. :param type_to_determine: The type of interaction to search for. :return: A list of all interactions that are resolved. \"\"\" _grab_member = cls . data . resolved [ type_to_determine ] . get ( query , None ) if _grab_member is not None : return _class_return [ type_to_determine ]( ** _grab_member ) return _grab_member","title":"resolved_interactions_finder()"},{"location":"Models/Incoming/#dispike.incoming.discord_types","text":"","title":"discord_types"},{"location":"Models/Incoming/#dispike.incoming.discord_types.channel","text":"","title":"channel"},{"location":"Models/Incoming/#dispike.incoming.discord_types.channel.ChannelTypes","text":"An enumeration.","title":"ChannelTypes"},{"location":"Models/Incoming/#dispike.incoming.discord_types.channel.PartialChannel","text":"A partial representation for a discord channel. This is found in a Application Command Interaction Data Resolved Structure Partial Channel objects only have id, name, type and permissions attributes.","title":"PartialChannel"},{"location":"Models/Incoming/#dispike.incoming.discord_types.member","text":"","title":"member"},{"location":"Models/Incoming/#dispike.incoming.discord_types.member.Member","text":"A representation of a discord member, intended for you to easily access attributes. this is not intended for you to edit, and will not be accepted as an argument in any function.","title":"Member"},{"location":"Models/Incoming/#dispike.incoming.discord_types.member.PartialMember","text":"A partial representation for a discord user. This is found in a Application Command Interaction Data Resolved Structure Partial Member objects are missing user, deaf and mute attributes.","title":"PartialMember"},{"location":"Models/Incoming/#dispike.incoming.discord_types.message","text":"","title":"message"},{"location":"Models/Incoming/#dispike.incoming.discord_types.message.Message","text":"A representation of a discord message, intended for you to easily access attributes. this is not intended for you to edit, and will not be accepted as an argument in any function.","title":"Message"},{"location":"Models/Incoming/#dispike.incoming.discord_types.message.MessageAttachment","text":"A message attachment","title":"MessageAttachment"},{"location":"Models/Incoming/#dispike.incoming.discord_types.user","text":"","title":"user"},{"location":"Models/Incoming/#dispike.incoming.discord_types.user.User","text":"A representation of a User object from discord. this is not intended for you to edit, and will not be accepted as an argument in any function.","title":"User"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions","text":"","title":"incoming_interactions"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingApplicationCommand","text":"An Incoming Application command, this is not intended for you to edit, and will not be accepted in any function Attributes: Name Type Description id int Id of the interaction. application_id int The id of your bot. name int Name of the command. description int Description of the command. options Union[List[CommandOption], List[SubcommandOption]] Selected options from the command. default_permission bool Bool whether if uses default permissions.","title":"IncomingApplicationCommand"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordButtonData","text":"Incoming button data. Attributes: Name Type Description custom_id str The custom id of this button.","title":"IncomingDiscordButtonData"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordButtonInteraction","text":"An incoming discord interaction that was triggered by a button press, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordButtonData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member TODO: IDK if this is the member that called the command originally or the one that used the button. token str Token of this interaction.","title":"IncomingDiscordButtonInteraction"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordMessageCommandData","text":"Incoming message command data. Attributes: Name Type Description target_id str The id of the targeted message. target Message The target message. name str The name of the message command.","title":"IncomingDiscordMessageCommandData"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordMessageCommandInteraction","text":"An incoming discord interaction that was triggered by a message command interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordMessageCommandData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member Member that called the command. token str Token of this interaction.","title":"IncomingDiscordMessageCommandInteraction"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordOption","text":"An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand Attributes: Name Type Description name str Name of the option value str Value of the option","title":"IncomingDiscordOption"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordSelectMenuData","text":"Incoming select menu data. Attributes: Name Type Description custom_id str The custom id of this button. values List[str] A list of string values that the user selected.","title":"IncomingDiscordSelectMenuData"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordSelectMenuInteraction","text":"An incoming discord interaction that was triggered by a select menu interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordSelectMenuData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member TODO: IDK if this is the member that called the command originally or the one that used the select menu. token str Token of this interaction.","title":"IncomingDiscordSelectMenuInteraction"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordSlashData","text":"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand Attributes: Name Type Description id str Id of the command name str Name of the command options Union[List[IncomingDiscordOption], List[SubcommandIncomingDiscordOptionList]] Options selected by the user","title":"IncomingDiscordSlashData"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordSlashInteraction","text":"An incoming discord interaction that was triggered by a command, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordSlashData Options from the command. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member Member that used this interaction. token str Token of this interaction.","title":"IncomingDiscordSlashInteraction"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordUserCommandData","text":"Incoming user command data. Attributes: Name Type Description target_id str The id of the targeted user. target Member The targeted member. name str The name of the user command.","title":"IncomingDiscordUserCommandData"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.IncomingDiscordUserCommandInteraction","text":"An incoming discord interaction that was triggered by a user command interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. Attributes: Name Type Description id int Id of the interaction. data IncomingDiscordUserCommandData Data from the interaction. guild_id int Guild ID where this happened. channel_id int Channel ID where this happened. member Member Member that called the command. token str Token of this interaction.","title":"IncomingDiscordUserCommandInteraction"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.SubcommandIncomingDiscordOptionList","text":"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand Attributes: Name Type Description name str Name of the subcommand options Union[List[IncomingDiscordOption], List[SubcommandIncomingDiscordOptionListChild]] Options selected by the user","title":"SubcommandIncomingDiscordOptionList"},{"location":"Models/Incoming/#dispike.incoming.incoming_interactions.SubcommandIncomingDiscordOptionListChild","text":"Attributes: Name Type Description name str Name of the subcommand options List[IncomingDiscordOption]] Options selected by the user","title":"SubcommandIncomingDiscordOptionListChild"},{"location":"Models/Outgoing/","text":"Outgoing Models \u00b6 To import these models from dispike.creating.models.options import < Object > Warning Version >=v0.5.7a adds support for VSCode to auto-complete attributes when creating these models. \u00b6 CommandChoice pydantic-model \u00b6 Represents a key-value command choice. Attributes: Name Type Description name str Name of the choice. value str Value of the choice. CommandOption pydantic-model \u00b6 Represents a standard command option (not a subcommand). Attributes: Name Type Description name str Name of the option. description str Description of the option. type OptionTypes The option type. required bool Whether or not this option is required. choices Union[List[dict], List[CommandChoice]] Possible choices for this option for the user to pick from. options Union[List[CommandChoice], List] If the option is a subcommand or subcommand group type, this nested options will be the parameters. CommandTypes \u00b6 Easy access to command types. Attributes: Name Type Description SLASH int Represents Type 1 USER int Represents Type 2 MESSAGE int Represents Type 3 DiscordCommand pydantic-model \u00b6 Represents a discord command. Attributes: Name Type Description id int Id of this command. name str Name of this command. description str Description of this command. options List[Union[SubcommandOption, CommandOption]] Options for this command. default_permission boolean whether the command is enabled by default when the app is added to a guild. Defaults to True. type Union[CommandTypes, int] The type of command. This defaults to SLASH OptionTypes \u00b6 Easy access to option types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 MENTIONABLE int Represents Type 9 NUMBER int Represents Type 10 SubcommandOption pydantic-model \u00b6 Represents a subcommand group usually you would put this as an option in a DiscordCommand Attributes: Name Type Description name str Name of this group. description str Description of this group. options List[CommandOption] Options for this group.","title":"Outgoing"},{"location":"Models/Outgoing/#outgoing-models","text":"To import these models from dispike.creating.models.options import < Object > Warning Version >=v0.5.7a adds support for VSCode to auto-complete attributes when creating these models.","title":"Outgoing Models"},{"location":"Models/Outgoing/#dispike.creating.models.options","text":"","title":"dispike.creating.models.options"},{"location":"Models/Outgoing/#dispike.creating.models.options.CommandChoice","text":"Represents a key-value command choice. Attributes: Name Type Description name str Name of the choice. value str Value of the choice.","title":"CommandChoice"},{"location":"Models/Outgoing/#dispike.creating.models.options.CommandOption","text":"Represents a standard command option (not a subcommand). Attributes: Name Type Description name str Name of the option. description str Description of the option. type OptionTypes The option type. required bool Whether or not this option is required. choices Union[List[dict], List[CommandChoice]] Possible choices for this option for the user to pick from. options Union[List[CommandChoice], List] If the option is a subcommand or subcommand group type, this nested options will be the parameters.","title":"CommandOption"},{"location":"Models/Outgoing/#dispike.creating.models.options.CommandTypes","text":"Easy access to command types. Attributes: Name Type Description SLASH int Represents Type 1 USER int Represents Type 2 MESSAGE int Represents Type 3","title":"CommandTypes"},{"location":"Models/Outgoing/#dispike.creating.models.options.DiscordCommand","text":"Represents a discord command. Attributes: Name Type Description id int Id of this command. name str Name of this command. description str Description of this command. options List[Union[SubcommandOption, CommandOption]] Options for this command. default_permission boolean whether the command is enabled by default when the app is added to a guild. Defaults to True. type Union[CommandTypes, int] The type of command. This defaults to SLASH","title":"DiscordCommand"},{"location":"Models/Outgoing/#dispike.creating.models.options.OptionTypes","text":"Easy access to option types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 MENTIONABLE int Represents Type 9 NUMBER int Represents Type 10","title":"OptionTypes"},{"location":"Models/Outgoing/#dispike.creating.models.options.SubcommandOption","text":"Represents a subcommand group usually you would put this as an option in a DiscordCommand Attributes: Name Type Description name str Name of this group. description str Description of this group. options List[CommandOption] Options for this group.","title":"SubcommandOption"},{"location":"Models/Read%20Only/Incoming/","text":"","title":"Incoming"},{"location":"responses/","text":"Responses \u00b6 Responses are what are returned to Discord. To create a proper response, you will need the DiscordResponse object. \u200b","title":"Info"},{"location":"responses/#responses","text":"Responses are what are returned to Discord. To create a proper response, you will need the DiscordResponse object. \u200b","title":"Responses"},{"location":"responses/DeferredMessages/","text":"Deferred Messages \u00b6 Deferred Messages are messages that will appear later to the user. Setting up the handler. \u00b6 Setting up the handler for deferred response commands are a little bit different compared to normal commands. Dispike will automatically run your handler function after responding to Discord. Warning You have 15 Minutes to respond back to Discord before the token expires. Deferred Responses are useful for commands that require background processing that otherwise would lead to an error if it was a standard command. Requirements \u00b6 Your handler must hint a return of DeferredResponse . Any other hinted return (or no hinted return) may result in a delay in your bot responding. When you are ready to send your respond, use the provided function .send_deferred_message in your bot instance. Warning Your handler must still be an async function! @bot . interaction . on ( \"new.code\" ) async def generate_secret_code ( ctx : IncomingDiscordInteraction ) -> DeferredResponse : data = _heavy_function () # Compute-heavy task here. # # Remember that you have 15 minutes to respond before the token # expires.. # await bot . send_deferred_message ( original_context = ctx , new_message = DiscordResponse ( content = \"back with a new response.\" ), ) Type hinting DeferredResponse lets Dispike know to immediately respond to Discord, and wait for your function to complet","title":"Deferred Responses"},{"location":"responses/DeferredMessages/#deferred-messages","text":"Deferred Messages are messages that will appear later to the user.","title":"Deferred Messages"},{"location":"responses/DeferredMessages/#setting-up-the-handler","text":"Setting up the handler for deferred response commands are a little bit different compared to normal commands. Dispike will automatically run your handler function after responding to Discord. Warning You have 15 Minutes to respond back to Discord before the token expires. Deferred Responses are useful for commands that require background processing that otherwise would lead to an error if it was a standard command.","title":"Setting up the handler."},{"location":"responses/DeferredMessages/#requirements","text":"Your handler must hint a return of DeferredResponse . Any other hinted return (or no hinted return) may result in a delay in your bot responding. When you are ready to send your respond, use the provided function .send_deferred_message in your bot instance. Warning Your handler must still be an async function! @bot . interaction . on ( \"new.code\" ) async def generate_secret_code ( ctx : IncomingDiscordInteraction ) -> DeferredResponse : data = _heavy_function () # Compute-heavy task here. # # Remember that you have 15 minutes to respond before the token # expires.. # await bot . send_deferred_message ( original_context = ctx , new_message = DiscordResponse ( content = \"back with a new response.\" ), ) Type hinting DeferredResponse lets Dispike know to immediately respond to Discord, and wait for your function to complet","title":"Requirements"},{"location":"responses/readyresponse/","text":"Ready Response \u00b6 The DiscordResponse is available as a convenience object to assist you in generating a proper payload to return to discord. Some methods and functions may require you to only use a valid DiscordResponse . from dispike import DiscordResponse # or from dispike.responses import DiscordResponse content , embeds , and tts is not required immediately, and can be configured later. However, settings such as show_user_input and follow_up_message are set at first initialization and cannot be changed. from dispike.responses import DiscordResponse response = DiscordResponse () response . content = \"Content Text Here\" from dispike.responses import DiscordResponse from dispike.helper import Embed async def sample_function ( ... ) -> DiscordResponse : ... return DiscordResponse ( content = \"Content Text Here\" , tts = False , embeds = [ Embed ( ... ), Embed ( ... )], show_user_input = True ) Empherical Messages \u00b6 Empherical messages (messages/responses that are only visible to the person who sent them ) are available by setting the optional empherical parameter to True . Info Setting a response to be empherical after initialization can be done by setting the ._is_empherical attribute. (Note this will be changed in newer versions of Dispike.) from dispike.responses import DiscordResponse response = DiscordResponse ( empherical = True ) response . content = \"Content Text Here\" Update original message \u00b6 Warning You can only update an original message if you are responding to a component interaction You can update the original message if you are responding to a component interaction. from dispike.responses import DiscordResponse response = DiscordResponse ( update_message = True ) response . content = \"Brand new content\" Buttons \u00b6 Info Remember to register an event for these buttons! DiscordResponse ( content = \"Content!\" , empherical = True , action_row = ActionRow ( components = [ Button ( label = \"Next\" , custom_id = \"tutorial_step1_next\" , style = ButtonStyles . PRIMARY , ), Button ( label = \"Cancel\" , custom_id = \"tutorial_cancel\" , style = ButtonStyles . DANGER , ), LinkButton ( label = \"Go to the docs!\" , url = \"https://dispike.ms7m.me/\" ) ] ), ), Select Menus \u00b6 Info Remember to register an event for this select menu! DiscordResponse ( content = \"Content!\" , action_row = ActionRow ( components = [ SelectMenu ( custom_id = \"class_select_1\" , placeholder = \"Choose a class\" , min_values = 1 , max_values = 1 , options = [ SelectMenu . SelectMenuOption ( label = \"Rogue\" , description = \"Sneak n stab\" , value = \"rogue\" , emoji = PartialEmoji ( name = \"rogue\" , id = \"625891304148303894\" ), ), SelectMenu . SelectMenuOption ( label = \"Mage\" , description = \"Turn 'em into a sheep\" , value = \"mage\" , emoji = PartialEmoji ( name = \"mage\" , id = \"625891304081063986\" ), ), ], disabled = False , ) ] ), ), Info DiscordResponse is simply a helper to help you generate a valid response to discord. If you can generate a valid response yourself, you can simply type-hint your function to hint at a dict and return a proper response. This is only recommended for Advanced users. \u00b6 Represents an outgoing Discord Response Attributes: Name Type Description content str A plain-text response to a user tts bool bool returning if the message should be spoken via tts. embeds dict a List representing .to_dict of an Embed object. response dict a valid response represented in a dict, to later be converted to JSON. action_row: ActionRow property readonly \u00b6 Returns a action row. Returns: Type Description ActionRow ActionRow: The action row. content: str property writable \u00b6 Either set or view the plain-text response to the user. Returns: Type Description str str: Content provided embeds: List [ dispike . helper . embed . Embed ] property readonly \u00b6 Returns a list of embeds to send to. Returns: Type Description List[dispike.helper.embed.Embed] List[Embed]: List of embeds in this object. response: dict property readonly \u00b6 A generated valid discord response Returns: Type Description dict dict: a valid discord response. tts: bool property writable \u00b6 Either set or view the tts attribute for the user. Returns: Type Description bool bool: tts __init__ ( self , content = None , tts = False , embeds = [], show_user_input = False , follow_up_message = False , empherical = False , allowed_mentions = None , action_row = None , update_message = False ) special \u00b6 Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Parameters: Name Type Description Default content str A plain-text response to a user None tts bool bool returning if the message should be spoken via tts False embeds List[dispike.helper.embed.Embed] a List representing .to_dict of an Embed object [] show_user_input bool Whether to delete the user's message of calling the command after responding. False follow_up_message bool Whether this is a follow up to a previous message. False empherical bool Whether to send message as an empherical message. False allowed_mentions AllowedMentions Let discord filter mentions per configuration. None update_message bool Whether to edit the original message this is responding too. False Source code in dispike/response.py def __init__ ( self , content : str = None , tts : bool = False , embeds : typing . List [ Embed ] = [], show_user_input : bool = False , follow_up_message = False , empherical = False , allowed_mentions : \"AllowedMentions\" = None , action_row : ActionRow = None , update_message = False , ): \"\"\"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Args: content (str, optional): A plain-text response to a user tts (bool, optional): bool returning if the message should be spoken via tts embeds (typing.List[Embed], optional): a List representing .to_dict of an Embed object show_user_input (bool, optional): Whether to delete the user's message of calling the command after responding. follow_up_message (bool, optional): Whether this is a follow up to a previous message. empherical (bool, optional): Whether to send message as an empherical message. allowed_mentions (List[AllowedMentions], optional): Let discord filter mentions per configuration. update_message (bool, optional): Whether to edit the original message this is responding too. \"\"\" if content is not None : if not isinstance ( content , str ): raise TypeError ( f \"Content must be a string\" ) elif content == \"\" : content = None # if isinstance(content, str) == False or content == \"\" or content != None: # raise TypeError(f\"content must be a string. recieved: {content}\") if not isinstance ( tts , bool ): raise TypeError ( \"tts must be a bool\" ) self . _content = content self . _tts = tts self . _embeds = embeds if action_row : self . _action_row = action_row else : self . _action_row = None if show_user_input : # show deprecation warning warnings . warn ( \"show_user_input is deprecated by Dispike as it is no longer supported by Discord. Future versions of dispike may remove this parameter entirely.\" , DeprecationWarning , ) # pragma: no cover logger . warning ( \"show_user_input is deprecated by Dispike as it is no longer supported by Discord. Future versions of dispike may remove this parameter entirely.\" ) # pragma: no cover self . _type_response = 4 if update_message : self . _type_response = 7 self . _is_followup = follow_up_message self . _is_empherical = empherical self . _allowed_mentions = allowed_mentions add_new_embed ( self , embed_to_add ) \u00b6 Append a new embed, provided with a proper Embed object Parameters: Name Type Description Default embed_to_add Embed Proper Embed Object required Exceptions: Type Description TypeError Raised if you do not pass a proper Embed object. Source code in dispike/response.py def add_new_embed ( self , embed_to_add : Embed ): \"\"\"Append a new embed, provided with a proper Embed object Args: embed_to_add (Embed): Proper Embed Object Raises: TypeError: Raised if you do not pass a proper Embed object. \"\"\" if isinstance ( embed_to_add , Embed ): self . _embeds . append ( embed_to_add ) else : raise TypeError ( \"embed must be a Embed object.\" )","title":"Ready Responses"},{"location":"responses/readyresponse/#ready-response","text":"The DiscordResponse is available as a convenience object to assist you in generating a proper payload to return to discord. Some methods and functions may require you to only use a valid DiscordResponse . from dispike import DiscordResponse # or from dispike.responses import DiscordResponse content , embeds , and tts is not required immediately, and can be configured later. However, settings such as show_user_input and follow_up_message are set at first initialization and cannot be changed. from dispike.responses import DiscordResponse response = DiscordResponse () response . content = \"Content Text Here\" from dispike.responses import DiscordResponse from dispike.helper import Embed async def sample_function ( ... ) -> DiscordResponse : ... return DiscordResponse ( content = \"Content Text Here\" , tts = False , embeds = [ Embed ( ... ), Embed ( ... )], show_user_input = True )","title":"Ready Response"},{"location":"responses/readyresponse/#empherical-messages","text":"Empherical messages (messages/responses that are only visible to the person who sent them ) are available by setting the optional empherical parameter to True . Info Setting a response to be empherical after initialization can be done by setting the ._is_empherical attribute. (Note this will be changed in newer versions of Dispike.) from dispike.responses import DiscordResponse response = DiscordResponse ( empherical = True ) response . content = \"Content Text Here\"","title":"Empherical Messages"},{"location":"responses/readyresponse/#update-original-message","text":"Warning You can only update an original message if you are responding to a component interaction You can update the original message if you are responding to a component interaction. from dispike.responses import DiscordResponse response = DiscordResponse ( update_message = True ) response . content = \"Brand new content\"","title":"Update original message"},{"location":"responses/readyresponse/#buttons","text":"Info Remember to register an event for these buttons! DiscordResponse ( content = \"Content!\" , empherical = True , action_row = ActionRow ( components = [ Button ( label = \"Next\" , custom_id = \"tutorial_step1_next\" , style = ButtonStyles . PRIMARY , ), Button ( label = \"Cancel\" , custom_id = \"tutorial_cancel\" , style = ButtonStyles . DANGER , ), LinkButton ( label = \"Go to the docs!\" , url = \"https://dispike.ms7m.me/\" ) ] ), ),","title":"Buttons"},{"location":"responses/readyresponse/#select-menus","text":"Info Remember to register an event for this select menu! DiscordResponse ( content = \"Content!\" , action_row = ActionRow ( components = [ SelectMenu ( custom_id = \"class_select_1\" , placeholder = \"Choose a class\" , min_values = 1 , max_values = 1 , options = [ SelectMenu . SelectMenuOption ( label = \"Rogue\" , description = \"Sneak n stab\" , value = \"rogue\" , emoji = PartialEmoji ( name = \"rogue\" , id = \"625891304148303894\" ), ), SelectMenu . SelectMenuOption ( label = \"Mage\" , description = \"Turn 'em into a sheep\" , value = \"mage\" , emoji = PartialEmoji ( name = \"mage\" , id = \"625891304081063986\" ), ), ], disabled = False , ) ] ), ), Info DiscordResponse is simply a helper to help you generate a valid response to discord. If you can generate a valid response yourself, you can simply type-hint your function to hint at a dict and return a proper response. This is only recommended for Advanced users.","title":"Select Menus"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse","text":"Represents an outgoing Discord Response Attributes: Name Type Description content str A plain-text response to a user tts bool bool returning if the message should be spoken via tts. embeds dict a List representing .to_dict of an Embed object. response dict a valid response represented in a dict, to later be converted to JSON.","title":"dispike.response.DiscordResponse"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.action_row","text":"Returns a action row. Returns: Type Description ActionRow ActionRow: The action row.","title":"action_row"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.content","text":"Either set or view the plain-text response to the user. Returns: Type Description str str: Content provided","title":"content"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.embeds","text":"Returns a list of embeds to send to. Returns: Type Description List[dispike.helper.embed.Embed] List[Embed]: List of embeds in this object.","title":"embeds"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.response","text":"A generated valid discord response Returns: Type Description dict dict: a valid discord response.","title":"response"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.tts","text":"Either set or view the tts attribute for the user. Returns: Type Description bool bool: tts","title":"tts"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.__init__","text":"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Parameters: Name Type Description Default content str A plain-text response to a user None tts bool bool returning if the message should be spoken via tts False embeds List[dispike.helper.embed.Embed] a List representing .to_dict of an Embed object [] show_user_input bool Whether to delete the user's message of calling the command after responding. False follow_up_message bool Whether this is a follow up to a previous message. False empherical bool Whether to send message as an empherical message. False allowed_mentions AllowedMentions Let discord filter mentions per configuration. None update_message bool Whether to edit the original message this is responding too. False Source code in dispike/response.py def __init__ ( self , content : str = None , tts : bool = False , embeds : typing . List [ Embed ] = [], show_user_input : bool = False , follow_up_message = False , empherical = False , allowed_mentions : \"AllowedMentions\" = None , action_row : ActionRow = None , update_message = False , ): \"\"\"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Args: content (str, optional): A plain-text response to a user tts (bool, optional): bool returning if the message should be spoken via tts embeds (typing.List[Embed], optional): a List representing .to_dict of an Embed object show_user_input (bool, optional): Whether to delete the user's message of calling the command after responding. follow_up_message (bool, optional): Whether this is a follow up to a previous message. empherical (bool, optional): Whether to send message as an empherical message. allowed_mentions (List[AllowedMentions], optional): Let discord filter mentions per configuration. update_message (bool, optional): Whether to edit the original message this is responding too. \"\"\" if content is not None : if not isinstance ( content , str ): raise TypeError ( f \"Content must be a string\" ) elif content == \"\" : content = None # if isinstance(content, str) == False or content == \"\" or content != None: # raise TypeError(f\"content must be a string. recieved: {content}\") if not isinstance ( tts , bool ): raise TypeError ( \"tts must be a bool\" ) self . _content = content self . _tts = tts self . _embeds = embeds if action_row : self . _action_row = action_row else : self . _action_row = None if show_user_input : # show deprecation warning warnings . warn ( \"show_user_input is deprecated by Dispike as it is no longer supported by Discord. Future versions of dispike may remove this parameter entirely.\" , DeprecationWarning , ) # pragma: no cover logger . warning ( \"show_user_input is deprecated by Dispike as it is no longer supported by Discord. Future versions of dispike may remove this parameter entirely.\" ) # pragma: no cover self . _type_response = 4 if update_message : self . _type_response = 7 self . _is_followup = follow_up_message self . _is_empherical = empherical self . _allowed_mentions = allowed_mentions","title":"__init__()"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.add_new_embed","text":"Append a new embed, provided with a proper Embed object Parameters: Name Type Description Default embed_to_add Embed Proper Embed Object required Exceptions: Type Description TypeError Raised if you do not pass a proper Embed object. Source code in dispike/response.py def add_new_embed ( self , embed_to_add : Embed ): \"\"\"Append a new embed, provided with a proper Embed object Args: embed_to_add (Embed): Proper Embed Object Raises: TypeError: Raised if you do not pass a proper Embed object. \"\"\" if isinstance ( embed_to_add , Embed ): self . _embeds . append ( embed_to_add ) else : raise TypeError ( \"embed must be a Embed object.\" )","title":"add_new_embed()"},{"location":"responses/writinghandler/","text":"Preface \u00b6 Writing a handler function is required to properly route interactions from the user to your bot. After request verification, the request (interaction) is passed to an IncomingDiscordInteraction object. You will write your handler as a function to directly accept an additional argument called ctx containing this interaction. It's normal not to use this interaction, it only exists to give you context about the interaction. Writing the handler. \u00b6 Your handler must be Async ( async def ) Accept the same number of arguments (if any) as the command with an additional argument for the context. python async def ...(argument_one, argument_two, ctx) -> ... Contain a bot.on(<command-identifier>, <event type>) decorator. OR Contain dispike.interactions.on(<command-identifier>, <event type>) decorator Finding the command identifier. \u00b6 Normal commands \u00b6 Finding the command identifier is simple. If you are writing a normal (non-subcommand) command, it's often just the command name. comma n d_ t o_be_regis tere d = DiscordComma n d( na me= \"wave\" , # t his is t he mai n comma n d na me. , descrip t io n = \"Send a wave to a nice person! \ud83d\udc4b \" , op t io ns = [ Comma n dOp t io n ( na me= \"person\" , # t his is t he a ttr ibu te assig ne d t o t he value passed. , descrip t io n = \"person to target\" , # t his describes t he value t o pass , required=True , t ype=Comma n dTypes.USER ) ] ) The command identifier in this case will be wave . @bot . interaction . on ( \"wave\" , EventTypes . COMMAND ) async def handle_wave ( person , ctx ) -> DiscordResponse : ... Subcommands \u00b6 Subcommands are similar but are more \"nested\". Each layer will be represented and separated by a . Take a look at this command that was registered command_configuration = DiscordCommand ( name = \"forex\" , description = \"Get Forex rates\" , options = [ SubcommandOption ( name = \"latest\" , description = \"Get latest forex rates.\" , type = 2 , options = [ CommandOption ( name = \"convert\" , description = \"View rates between two symbols.\" , type = 1 , required = False , options = [ { \"name\" : \"symbol_1\" , \"description\" : \"Symbol 1\" , \"type\" : CommandTypes . STRING , \"required\" : True , }, { \"name\" : \"symbol_2\" , \"description\" : \"Symbol 2\" , \"type\" : CommandTypes . STRING , \"required\" : False , }, ], ) ], ) ], ) When a user uses this command in discord. They'd use it as /forex latest convert <SYMBOL 1> <SYMBOL 2> The command identifier would be represented as forex.latest.convert Buttons and Select Menus \u00b6 Finding the command identifier for buttons or select menus can be found by finding the custom_id attribute in either Buttons or SelectMenu . Defining the arguments \u00b6 You must define the same number of arguments in your python function as the discord command . Warning If you have an optional argument, you can pass the **kwargs argument to your function. Learn more about the *kwargs argument here . If the user adds an optional argument, this will be passed to the function. Otherwise, it will not be present. Write your code to check if it exists before doing anything! The command argument names must match to the one set as the value when registering your command. @bot . interaction . on ( \"forex.latest.convert\" , EventTypes . COMMAND ) async def handle_forex_convert ( symbol_1 : str , symbol_2 : str , ctx : IncomingDiscordInteraction ) -> DiscordResponse : ...","title":"Writing your Handler"},{"location":"responses/writinghandler/#preface","text":"Writing a handler function is required to properly route interactions from the user to your bot. After request verification, the request (interaction) is passed to an IncomingDiscordInteraction object. You will write your handler as a function to directly accept an additional argument called ctx containing this interaction. It's normal not to use this interaction, it only exists to give you context about the interaction.","title":"Preface"},{"location":"responses/writinghandler/#writing-the-handler","text":"Your handler must be Async ( async def ) Accept the same number of arguments (if any) as the command with an additional argument for the context. python async def ...(argument_one, argument_two, ctx) -> ... Contain a bot.on(<command-identifier>, <event type>) decorator. OR Contain dispike.interactions.on(<command-identifier>, <event type>) decorator","title":"Writing the handler."},{"location":"responses/writinghandler/#finding-the-command-identifier","text":"","title":"Finding the command identifier."},{"location":"responses/writinghandler/#normal-commands","text":"Finding the command identifier is simple. If you are writing a normal (non-subcommand) command, it's often just the command name. comma n d_ t o_be_regis tere d = DiscordComma n d( na me= \"wave\" , # t his is t he mai n comma n d na me. , descrip t io n = \"Send a wave to a nice person! \ud83d\udc4b \" , op t io ns = [ Comma n dOp t io n ( na me= \"person\" , # t his is t he a ttr ibu te assig ne d t o t he value passed. , descrip t io n = \"person to target\" , # t his describes t he value t o pass , required=True , t ype=Comma n dTypes.USER ) ] ) The command identifier in this case will be wave . @bot . interaction . on ( \"wave\" , EventTypes . COMMAND ) async def handle_wave ( person , ctx ) -> DiscordResponse : ...","title":"Normal commands"},{"location":"responses/writinghandler/#subcommands","text":"Subcommands are similar but are more \"nested\". Each layer will be represented and separated by a . Take a look at this command that was registered command_configuration = DiscordCommand ( name = \"forex\" , description = \"Get Forex rates\" , options = [ SubcommandOption ( name = \"latest\" , description = \"Get latest forex rates.\" , type = 2 , options = [ CommandOption ( name = \"convert\" , description = \"View rates between two symbols.\" , type = 1 , required = False , options = [ { \"name\" : \"symbol_1\" , \"description\" : \"Symbol 1\" , \"type\" : CommandTypes . STRING , \"required\" : True , }, { \"name\" : \"symbol_2\" , \"description\" : \"Symbol 2\" , \"type\" : CommandTypes . STRING , \"required\" : False , }, ], ) ], ) ], ) When a user uses this command in discord. They'd use it as /forex latest convert <SYMBOL 1> <SYMBOL 2> The command identifier would be represented as forex.latest.convert","title":"Subcommands"},{"location":"responses/writinghandler/#buttons-and-select-menus","text":"Finding the command identifier for buttons or select menus can be found by finding the custom_id attribute in either Buttons or SelectMenu .","title":"Buttons and Select Menus"},{"location":"responses/writinghandler/#defining-the-arguments","text":"You must define the same number of arguments in your python function as the discord command . Warning If you have an optional argument, you can pass the **kwargs argument to your function. Learn more about the *kwargs argument here . If the user adds an optional argument, this will be passed to the function. Otherwise, it will not be present. Write your code to check if it exists before doing anything! The command argument names must match to the one set as the value when registering your command. @bot . interaction . on ( \"forex.latest.convert\" , EventTypes . COMMAND ) async def handle_forex_convert ( symbol_1 : str , symbol_2 : str , ctx : IncomingDiscordInteraction ) -> DiscordResponse : ...","title":"Defining the arguments"},{"location":"tutorial/Configuring%20commands/","text":"Configuring commands \u00b6 Creating a command is very similar to creating it in JSON, however, this library will assist you in making sure the outcome is a valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to integrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow the discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.creating import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.creating import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not covered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command.","title":"Configuring Commands"},{"location":"tutorial/Configuring%20commands/#configuring-commands","text":"Creating a command is very similar to creating it in JSON, however, this library will assist you in making sure the outcome is a valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to integrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow the discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.creating import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.creating import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not covered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command.","title":"Configuring commands"},{"location":"tutorial/Getting%20Started/","text":"Getting Started \u00b6 Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice An example bot is available here","title":"Getting Started"},{"location":"tutorial/Getting%20Started/#getting-started","text":"Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice An example bot is available here","title":"Getting Started"},{"location":"tutorial/Registering%20Commands/","text":"Registering Commands \u00b6 We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering, and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register ( command_to_be_created ) \u00b6 allowed_mentions \u00b6 AllowedMentionTypes \u00b6 An enumeration. components \u00b6 ActionRow \u00b6 Represents a action row component __init__ ( self , components ) special \u00b6 Parameters: Name Type Description Default components List[Union[dispike.creating.components.Button, dispike.creating.components.LinkButton, dispike.creating.components.SelectMenu]] Components for this action row. You cannot combine buttons and select menus required Source code in dispike/creating/components.py def __init__ ( self , components : typing . List [ typing . Union [ Button , LinkButton , SelectMenu ]] ): \"\"\" Args: components (typing.List[typing.Union[Button, LinkButton, SelectMenu]]): Components for this action row. You cannot combine buttons and select menus \"\"\" self . type = ComponentTypes . ACTION_ROW # Do a heap of stuff to figure out if a select menu is being combined with a button contains_button = False contains_select_menu = False for component in components : if isinstance ( component , ( Button , LinkButton )): contains_button = True elif isinstance ( component , SelectMenu ): contains_select_menu = True else : # raise error if neither. raise InvalidComponentError ( type ( component )) if contains_button and contains_select_menu : raise ComponentCombinationError ( \"You cannot combine buttons and select menus\" ) self . components = components Button \u00b6 Represents a partial Discord emoji __init__ ( self , label = None , custom_id = None , disabled = False , style =< ButtonStyles . PRIMARY : 1 > , emoji = None ) special \u00b6 Parameters: Name Type Description Default label str label of the button. None custom_id str custom id of the button. None disabled bool bool specifying if this button should be disabled. False style ButtonStyles style of the button. Cannot be LINK <ButtonStyles.PRIMARY: 1> emoji PartialEmoji a partial emoji. None Source code in dispike/creating/components.py def __init__ ( self , label : str = None , custom_id : str = None , disabled : bool = False , style : ButtonStyles = ButtonStyles . PRIMARY , emoji : PartialEmoji = None , ): \"\"\" Args: label (str): label of the button. custom_id (str, optional): custom id of the button. disabled (bool, optional): bool specifying if this button should be disabled. style (ButtonStyles, optional): style of the button. Cannot be LINK emoji (PartialEmoji, optional): a partial emoji. \"\"\" self . type = ComponentTypes . BUTTON if style == ButtonStyles . LINK : raise TypeError ( \"style cannot be type Link\" ) if not label : raise TypeError ( \"label cannot be None\" ) if not custom_id : raise TypeError ( \"custom_id cannot be None\" ) self . style = style self . label = label self . custom_id = custom_id self . disabled = disabled self . emoji = emoji ButtonStyles \u00b6 Easy access to button styles. Attributes: Name Type Description PRIMARY int Represents Style 1 SECONDARY int Represents Style 2 SUCCESS int Represents Style 3 DANGER int Represents Style 4 LINK int Represents Style 5 ComponentTypes \u00b6 Easy access to component types. Attributes: Name Type Description ACTION_ROW int Represents Type 1 BUTTON int Represents Type 2 SELECT_MENU int Represents Type 3 LinkButton \u00b6 Represents a partial Discord emoji __init__ ( self , label = None , url = None , disabled = False ) special \u00b6 Parameters: Name Type Description Default label str Label of the button. None url str Url of the link button. None disabled bool bool Specifying if this button should be disabled. False Source code in dispike/creating/components.py def __init__ ( self , label : str = None , url : str = None , disabled : bool = False ): \"\"\" Args: label (str): Label of the button. url (str): Url of the link button. disabled (bool, optional): bool Specifying if this button should be disabled. \"\"\" self . type = ComponentTypes . BUTTON self . style = ButtonStyles . LINK if not url : raise TypeError ( \"url cannot be None\" ) if not label : raise TypeError ( \"label cannot be None\" ) self . label = label self . url = url self . disabled = disabled PartialEmoji \u00b6 Represents a partial Discord emoji __init__ ( self , name , id = None , animated = None ) special \u00b6 Parameters: Name Type Description Default name str The emojis name, or unicode symbol. required id str id of the emoji, if not a unicode one. None animated bool bool Specifying if this emoji should be animated, if not a unicode one. None Source code in dispike/creating/components.py def __init__ ( self , name : str , id : str = None , animated : bool = None ): \"\"\" Args: name (str): The emojis name, or unicode symbol. id (str, optional): id of the emoji, if not a unicode one. animated (bool, options): bool Specifying if this emoji should be animated, if not a unicode one. \"\"\" self . name = name self . id = id self . animated = animated SelectMenu \u00b6 Represents a Discord select menu SelectMenuOption \u00b6 Represents a Discord select menu option __init__ ( self , label = None , value = None , description = None , emoji = None , default = False ) special \u00b6 Parameters: Name Type Description Default label str Label of the option. None value str Internal value of the option. None description str Description of the option. None emoji PartialEmoji A partial emoji None default bool Whether or not this option should be the default. False Source code in dispike/creating/components.py def __init__ ( self , label : str = None , value : str = None , description : str = None , emoji : PartialEmoji = None , default : bool = False , ): \"\"\" Args: label (str): Label of the option. value (str): Internal value of the option. description (str): Description of the option. emoji (PartialEmoji, optional): A partial emoji default (bool): Whether or not this option should be the default. \"\"\" if not label : raise TypeError ( \"label cannot be None\" ) if not value : raise TypeError ( \"value cannot be None\" ) self . label = label self . value = value self . description = description self . emoji = emoji self . default = default __init__ ( self , custom_id , options , placeholder , min_values , max_values , disabled ) special \u00b6 Parameters: Name Type Description Default custom_id str Custom id of the menu. required options List[dispike.creating.components.SelectMenu.SelectMenuOption] List of SelectMenu.SelectMenuOption's required placeholder str Text that's shown before a user selects anything. required min_values int The minimum amount of values a user can select. Cannot be lower than 0 required max_values int The maximum amount of values a user can select. Cannot be higher than the amount of options. required disabled False Whether to disable menu required Source code in dispike/creating/components.py def __init__ ( self , custom_id : str , options : typing . List [ SelectMenuOption ], placeholder : str , min_values : int , max_values : int , disabled : False , ): \"\"\" Args: custom_id (str): Custom id of the menu. options (SelectMenu.SelectMenuOption): List of SelectMenu.SelectMenuOption's placeholder (str, optional): Text that's shown before a user selects anything. min_values (int): The minimum amount of values a user can select. Cannot be lower than 0 max_values (int): The maximum amount of values a user can select. Cannot be higher than the amount of options. disabled (bool, optional): Whether to disable menu \"\"\" self . type = ComponentTypes . SELECT_MENU self . options = options for option in options : if not isinstance ( option , SelectMenu . SelectMenuOption ): raise SelectMenuOptionError ( f \" { option } is not type SelectMenuOption\" ) if not placeholder : raise TypeError ( \"placeholder cannot be None\" ) if not custom_id : raise TypeError ( \"custom_id cannot be None\" ) self . placeholder = placeholder self . custom_id = custom_id if not min_values or not max_values : raise TypeError ( \"min_values or max_values must not be None\" ) if max_values > len ( options ): raise TypeError ( \"max_values cannot be larger than how many options you have\" ) if min_values < 1 : raise TypeError ( \"min_values cannot be less than 0\" ) self . min_values = min_values self . max_values = max_values self . disabled = disabled models special \u00b6 options \u00b6 CommandChoice pydantic-model \u00b6 Represents a key-value command choice. Attributes: Name Type Description name str Name of the choice. value str Value of the choice. CommandOption pydantic-model \u00b6 Represents a standard command option (not a subcommand). Attributes: Name Type Description name str Name of the option. description str Description of the option. type OptionTypes The option type. required bool Whether or not this option is required. choices Union[List[dict], List[CommandChoice]] Possible choices for this option for the user to pick from. options Union[List[CommandChoice], List] If the option is a subcommand or subcommand group type, this nested options will be the parameters. CommandTypes \u00b6 Easy access to command types. Attributes: Name Type Description SLASH int Represents Type 1 USER int Represents Type 2 MESSAGE int Represents Type 3 DiscordCommand pydantic-model \u00b6 Represents a discord command. Attributes: Name Type Description id int Id of this command. name str Name of this command. description str Description of this command. options List[Union[SubcommandOption, CommandOption]] Options for this command. default_permission boolean whether the command is enabled by default when the app is added to a guild. Defaults to True. type Union[CommandTypes, int] The type of command. This defaults to SLASH OptionTypes \u00b6 Easy access to option types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 MENTIONABLE int Represents Type 9 NUMBER int Represents Type 10 SubcommandOption pydantic-model \u00b6 Represents a subcommand group usually you would put this as an option in a DiscordCommand Attributes: Name Type Description name str Name of this group. description str Description of this group. options List[CommandOption] Options for this group. permissions \u00b6 ApplicationCommandPermissions pydantic-model \u00b6 An individual permission for a command. ApplicationCommandPermissionType \u00b6 The permission type of the Application Command. GuildApplicationCommandPermissions pydantic-model \u00b6 Returned when fetching the permissions for a command in a guild. registrator \u00b6 RegisterCommands \u00b6 This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async. bot_token property writable \u00b6 You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value request_headers property readonly \u00b6 Return a valid header for authorization Returns: Type Description dict a valid header for authorization __init__ ( self , application_id , bot_token ) special \u00b6 Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/creating/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" , event_hooks = { \"response\" : [ dispike_httpx_event_hook_incoming_request ], \"request\" : [ dispike_httpx_event_hook_outgoing_request ], }, ) bulk_overwrite_commands ( self , commands , guild_only = False , guild_to_target = None ) \u00b6 Bulk OVERWRITE commands to specific guilds or globally. Parameters: Name Type Description Default commands List[dispike.creating.models.options.DiscordCommand] List of new commands (these commands will be overwritten) required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py @logger . catch ( reraise = True , message = \"Issue with bulk overrwriting commands\" ) def bulk_overwrite_commands ( self , commands : typing . List [ DiscordCommand ], guild_only : bool = False , guild_to_target : int = None , ): \"\"\"Bulk OVERWRITE commands to specific guilds or globally. Args: commands (typing.List[DiscordCommand]): List of new commands (these commands will be overwritten) guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" _commands_to_json = [ command . dict ( exclude_none = True ) for command in commands ] _send_request = self . _client . put ( url = _request_url , json = _commands_to_json , headers = self . request_headers ) if _send_request . status_code == 200 : logger . info ( f \"Overwritten { len ( _send_request . json ()) } commands.. Recieved ( { len ( _commands_to_json ) } \" ) return True else : logger . debug ( f \"BULK Overwrite failed ( { guild_only } = { guild_to_target } ): Body: { _commands_to_json } .. Status code: { _send_request . status_code } \" ) raise DiscordAPIError ( _send_request . status_code , _send_request . text ) register ( self , command , guild_only = False , guild_to_target = None ) \u00b6 Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#registering-commands","text":"We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering, and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register ( command_to_be_created )","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#dispike.creating","text":"","title":"dispike.creating"},{"location":"tutorial/Registering%20Commands/#dispike.creating.allowed_mentions","text":"","title":"allowed_mentions"},{"location":"tutorial/Registering%20Commands/#dispike.creating.allowed_mentions.AllowedMentionTypes","text":"An enumeration.","title":"AllowedMentionTypes"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components","text":"","title":"components"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.ActionRow","text":"Represents a action row component","title":"ActionRow"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.ActionRow.__init__","text":"Parameters: Name Type Description Default components List[Union[dispike.creating.components.Button, dispike.creating.components.LinkButton, dispike.creating.components.SelectMenu]] Components for this action row. You cannot combine buttons and select menus required Source code in dispike/creating/components.py def __init__ ( self , components : typing . List [ typing . Union [ Button , LinkButton , SelectMenu ]] ): \"\"\" Args: components (typing.List[typing.Union[Button, LinkButton, SelectMenu]]): Components for this action row. You cannot combine buttons and select menus \"\"\" self . type = ComponentTypes . ACTION_ROW # Do a heap of stuff to figure out if a select menu is being combined with a button contains_button = False contains_select_menu = False for component in components : if isinstance ( component , ( Button , LinkButton )): contains_button = True elif isinstance ( component , SelectMenu ): contains_select_menu = True else : # raise error if neither. raise InvalidComponentError ( type ( component )) if contains_button and contains_select_menu : raise ComponentCombinationError ( \"You cannot combine buttons and select menus\" ) self . components = components","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.Button","text":"Represents a partial Discord emoji","title":"Button"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.Button.__init__","text":"Parameters: Name Type Description Default label str label of the button. None custom_id str custom id of the button. None disabled bool bool specifying if this button should be disabled. False style ButtonStyles style of the button. Cannot be LINK <ButtonStyles.PRIMARY: 1> emoji PartialEmoji a partial emoji. None Source code in dispike/creating/components.py def __init__ ( self , label : str = None , custom_id : str = None , disabled : bool = False , style : ButtonStyles = ButtonStyles . PRIMARY , emoji : PartialEmoji = None , ): \"\"\" Args: label (str): label of the button. custom_id (str, optional): custom id of the button. disabled (bool, optional): bool specifying if this button should be disabled. style (ButtonStyles, optional): style of the button. Cannot be LINK emoji (PartialEmoji, optional): a partial emoji. \"\"\" self . type = ComponentTypes . BUTTON if style == ButtonStyles . LINK : raise TypeError ( \"style cannot be type Link\" ) if not label : raise TypeError ( \"label cannot be None\" ) if not custom_id : raise TypeError ( \"custom_id cannot be None\" ) self . style = style self . label = label self . custom_id = custom_id self . disabled = disabled self . emoji = emoji","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.ButtonStyles","text":"Easy access to button styles. Attributes: Name Type Description PRIMARY int Represents Style 1 SECONDARY int Represents Style 2 SUCCESS int Represents Style 3 DANGER int Represents Style 4 LINK int Represents Style 5","title":"ButtonStyles"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.ComponentTypes","text":"Easy access to component types. Attributes: Name Type Description ACTION_ROW int Represents Type 1 BUTTON int Represents Type 2 SELECT_MENU int Represents Type 3","title":"ComponentTypes"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.LinkButton","text":"Represents a partial Discord emoji","title":"LinkButton"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.LinkButton.__init__","text":"Parameters: Name Type Description Default label str Label of the button. None url str Url of the link button. None disabled bool bool Specifying if this button should be disabled. False Source code in dispike/creating/components.py def __init__ ( self , label : str = None , url : str = None , disabled : bool = False ): \"\"\" Args: label (str): Label of the button. url (str): Url of the link button. disabled (bool, optional): bool Specifying if this button should be disabled. \"\"\" self . type = ComponentTypes . BUTTON self . style = ButtonStyles . LINK if not url : raise TypeError ( \"url cannot be None\" ) if not label : raise TypeError ( \"label cannot be None\" ) self . label = label self . url = url self . disabled = disabled","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.PartialEmoji","text":"Represents a partial Discord emoji","title":"PartialEmoji"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.PartialEmoji.__init__","text":"Parameters: Name Type Description Default name str The emojis name, or unicode symbol. required id str id of the emoji, if not a unicode one. None animated bool bool Specifying if this emoji should be animated, if not a unicode one. None Source code in dispike/creating/components.py def __init__ ( self , name : str , id : str = None , animated : bool = None ): \"\"\" Args: name (str): The emojis name, or unicode symbol. id (str, optional): id of the emoji, if not a unicode one. animated (bool, options): bool Specifying if this emoji should be animated, if not a unicode one. \"\"\" self . name = name self . id = id self . animated = animated","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.SelectMenu","text":"Represents a Discord select menu","title":"SelectMenu"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.SelectMenu.SelectMenuOption","text":"Represents a Discord select menu option","title":"SelectMenuOption"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.SelectMenu.SelectMenuOption.__init__","text":"Parameters: Name Type Description Default label str Label of the option. None value str Internal value of the option. None description str Description of the option. None emoji PartialEmoji A partial emoji None default bool Whether or not this option should be the default. False Source code in dispike/creating/components.py def __init__ ( self , label : str = None , value : str = None , description : str = None , emoji : PartialEmoji = None , default : bool = False , ): \"\"\" Args: label (str): Label of the option. value (str): Internal value of the option. description (str): Description of the option. emoji (PartialEmoji, optional): A partial emoji default (bool): Whether or not this option should be the default. \"\"\" if not label : raise TypeError ( \"label cannot be None\" ) if not value : raise TypeError ( \"value cannot be None\" ) self . label = label self . value = value self . description = description self . emoji = emoji self . default = default","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.components.SelectMenu.__init__","text":"Parameters: Name Type Description Default custom_id str Custom id of the menu. required options List[dispike.creating.components.SelectMenu.SelectMenuOption] List of SelectMenu.SelectMenuOption's required placeholder str Text that's shown before a user selects anything. required min_values int The minimum amount of values a user can select. Cannot be lower than 0 required max_values int The maximum amount of values a user can select. Cannot be higher than the amount of options. required disabled False Whether to disable menu required Source code in dispike/creating/components.py def __init__ ( self , custom_id : str , options : typing . List [ SelectMenuOption ], placeholder : str , min_values : int , max_values : int , disabled : False , ): \"\"\" Args: custom_id (str): Custom id of the menu. options (SelectMenu.SelectMenuOption): List of SelectMenu.SelectMenuOption's placeholder (str, optional): Text that's shown before a user selects anything. min_values (int): The minimum amount of values a user can select. Cannot be lower than 0 max_values (int): The maximum amount of values a user can select. Cannot be higher than the amount of options. disabled (bool, optional): Whether to disable menu \"\"\" self . type = ComponentTypes . SELECT_MENU self . options = options for option in options : if not isinstance ( option , SelectMenu . SelectMenuOption ): raise SelectMenuOptionError ( f \" { option } is not type SelectMenuOption\" ) if not placeholder : raise TypeError ( \"placeholder cannot be None\" ) if not custom_id : raise TypeError ( \"custom_id cannot be None\" ) self . placeholder = placeholder self . custom_id = custom_id if not min_values or not max_values : raise TypeError ( \"min_values or max_values must not be None\" ) if max_values > len ( options ): raise TypeError ( \"max_values cannot be larger than how many options you have\" ) if min_values < 1 : raise TypeError ( \"min_values cannot be less than 0\" ) self . min_values = min_values self . max_values = max_values self . disabled = disabled","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models","text":"","title":"models"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options","text":"","title":"options"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options.CommandChoice","text":"Represents a key-value command choice. Attributes: Name Type Description name str Name of the choice. value str Value of the choice.","title":"CommandChoice"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options.CommandOption","text":"Represents a standard command option (not a subcommand). Attributes: Name Type Description name str Name of the option. description str Description of the option. type OptionTypes The option type. required bool Whether or not this option is required. choices Union[List[dict], List[CommandChoice]] Possible choices for this option for the user to pick from. options Union[List[CommandChoice], List] If the option is a subcommand or subcommand group type, this nested options will be the parameters.","title":"CommandOption"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options.CommandTypes","text":"Easy access to command types. Attributes: Name Type Description SLASH int Represents Type 1 USER int Represents Type 2 MESSAGE int Represents Type 3","title":"CommandTypes"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options.DiscordCommand","text":"Represents a discord command. Attributes: Name Type Description id int Id of this command. name str Name of this command. description str Description of this command. options List[Union[SubcommandOption, CommandOption]] Options for this command. default_permission boolean whether the command is enabled by default when the app is added to a guild. Defaults to True. type Union[CommandTypes, int] The type of command. This defaults to SLASH","title":"DiscordCommand"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options.OptionTypes","text":"Easy access to option types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 MENTIONABLE int Represents Type 9 NUMBER int Represents Type 10","title":"OptionTypes"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.options.SubcommandOption","text":"Represents a subcommand group usually you would put this as an option in a DiscordCommand Attributes: Name Type Description name str Name of this group. description str Description of this group. options List[CommandOption] Options for this group.","title":"SubcommandOption"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.permissions","text":"","title":"permissions"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.permissions.ApplicationCommandPermissions","text":"An individual permission for a command.","title":"ApplicationCommandPermissions"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.permissions.ApplicationCommandPermissionType","text":"The permission type of the Application Command.","title":"ApplicationCommandPermissionType"},{"location":"tutorial/Registering%20Commands/#dispike.creating.models.permissions.GuildApplicationCommandPermissions","text":"Returned when fetching the permissions for a command in a guild.","title":"GuildApplicationCommandPermissions"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator","text":"","title":"registrator"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator.RegisterCommands","text":"This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async.","title":"RegisterCommands"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator.RegisterCommands.bot_token","text":"You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value","title":"bot_token"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator.RegisterCommands.request_headers","text":"Return a valid header for authorization Returns: Type Description dict a valid header for authorization","title":"request_headers"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator.RegisterCommands.__init__","text":"Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/creating/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" , event_hooks = { \"response\" : [ dispike_httpx_event_hook_incoming_request ], \"request\" : [ dispike_httpx_event_hook_outgoing_request ], }, )","title":"__init__()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator.RegisterCommands.bulk_overwrite_commands","text":"Bulk OVERWRITE commands to specific guilds or globally. Parameters: Name Type Description Default commands List[dispike.creating.models.options.DiscordCommand] List of new commands (these commands will be overwritten) required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py @logger . catch ( reraise = True , message = \"Issue with bulk overrwriting commands\" ) def bulk_overwrite_commands ( self , commands : typing . List [ DiscordCommand ], guild_only : bool = False , guild_to_target : int = None , ): \"\"\"Bulk OVERWRITE commands to specific guilds or globally. Args: commands (typing.List[DiscordCommand]): List of new commands (these commands will be overwritten) guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" _commands_to_json = [ command . dict ( exclude_none = True ) for command in commands ] _send_request = self . _client . put ( url = _request_url , json = _commands_to_json , headers = self . request_headers ) if _send_request . status_code == 200 : logger . info ( f \"Overwritten { len ( _send_request . json ()) } commands.. Recieved ( { len ( _commands_to_json ) } \" ) return True else : logger . debug ( f \"BULK Overwrite failed ( { guild_only } = { guild_to_target } ): Body: { _commands_to_json } .. Status code: { _send_request . status_code } \" ) raise DiscordAPIError ( _send_request . status_code , _send_request . text )","title":"bulk_overwrite_commands()"},{"location":"tutorial/Registering%20Commands/#dispike.creating.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/creating/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"register()"},{"location":"tutorial/Running%20the%20bot/","text":"Running your bot. \u00b6 Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckily there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok. Start ngrok. \u00b6 Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification. Start the bot. \u00b6 There are multiple ways to run the bot. We\u2019re going to use the simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass. Run some commands. \u00b6 Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Running The Bot"},{"location":"tutorial/Running%20the%20bot/#running-your-bot","text":"Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckily there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok.","title":"Running your bot."},{"location":"tutorial/Running%20the%20bot/#start-ngrok","text":"Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification.","title":"Start ngrok."},{"location":"tutorial/Running%20the%20bot/#start-the-bot","text":"There are multiple ways to run the bot. We\u2019re going to use the simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass.","title":"Start the bot."},{"location":"tutorial/Running%20the%20bot/#run-some-commands","text":"Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Run some commands."},{"location":"tutorial/Writing%20the%20handler/","text":"Writing your first handler. \u00b6 You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , or a dict . Warning If you return a dict , it will not be verified and Dispike will assume that\u2019s valid and return the result to Discord. Your function must accept the same number of arguments you registered with Discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an argument named person , the function argument must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python Incoming Context \u00b6 Earlier you learned that you must account for an extra argument due to Dispike also passing a context about the command to your argument. Incoming context is type hinted, and your IDE should be able to auto-complete attributes. Writing your function \u00b6 from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . on ( \"wave\" , EventTypes . COMMAND ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.on('wave', EventTypes.COMMAND) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument is named \u201cperson\u201d, as well as the context that we will be receiving. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests slightly faster to respond, as Dispike would not have to guess what your response type is.","title":"Writing The Handler"},{"location":"tutorial/Writing%20the%20handler/#writing-your-first-handler","text":"You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , or a dict . Warning If you return a dict , it will not be verified and Dispike will assume that\u2019s valid and return the result to Discord. Your function must accept the same number of arguments you registered with Discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an argument named person , the function argument must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python","title":"Writing your first handler."},{"location":"tutorial/Writing%20the%20handler/#incoming-context","text":"Earlier you learned that you must account for an extra argument due to Dispike also passing a context about the command to your argument. Incoming context is type hinted, and your IDE should be able to auto-complete attributes.","title":"Incoming Context"},{"location":"tutorial/Writing%20the%20handler/#writing-your-function","text":"from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . on ( \"wave\" , EventTypes . COMMAND ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.on('wave', EventTypes.COMMAND) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument is named \u201cperson\u201d, as well as the context that we will be receiving. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests slightly faster to respond, as Dispike would not have to guess what your response type is.","title":"Writing your function"},{"location":"tutorial/Bigger%20Applications/Passing%20Callbacks%20Directly/","text":"Passing Callbacks Directly \u00b6 If you choose not to use EventCollections directly, you can pass any async function. from dispike import interactions async def sample ( ... ): return ... from dispike import Dispike bot = Dispike ( ... ) bot . register_event_command ( function_event_name = \"sample\" , function = sample , function_type = EventTypes . COMMAND ) \u00b6 This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Parameters: Name Type Description Default function_event_name str Function event name required function Callable Function to register. Must be async required function_type EventTypes [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. None Exceptions: Type Description AttributeError If function_type is not a string or None, and it cannot be found in the functions attributes. Source code in dispike/main.py def register_event_command ( self , function_event_name : str , function : typing . Callable , function_type : EventTypes = None , ** kwargs , ): \"\"\"This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Args: function_event_name (str): Function event name function (typing.Callable): Function to register. Must be async function_type (EventTypes): [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. Raises: AttributeError: If function_type is not a string or None, and it cannot be found in the functions attributes. \"\"\" if function_type is None : # try to see if the function has a _event_type attribute try : function_type = function . _dispike_event_type except AttributeError : raise AttributeError ( \"Unable to find function event type attribute inside function.. Did you add a decorator to this function?\" ) else : if isinstance ( function_type , EventTypes ): function_type = function_type self . _add_function_to_callbacks ( function_name = function_event_name , function_type = function_type , function = function , )","title":"Passing Callbacks Directly"},{"location":"tutorial/Bigger%20Applications/Passing%20Callbacks%20Directly/#passing-callbacks-directly","text":"If you choose not to use EventCollections directly, you can pass any async function. from dispike import interactions async def sample ( ... ): return ... from dispike import Dispike bot = Dispike ( ... ) bot . register_event_command ( function_event_name = \"sample\" , function = sample , function_type = EventTypes . COMMAND )","title":"Passing Callbacks Directly"},{"location":"tutorial/Bigger%20Applications/Passing%20Callbacks%20Directly/#dispike.main.Dispike.register_event_command","text":"This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Parameters: Name Type Description Default function_event_name str Function event name required function Callable Function to register. Must be async required function_type EventTypes [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. None Exceptions: Type Description AttributeError If function_type is not a string or None, and it cannot be found in the functions attributes. Source code in dispike/main.py def register_event_command ( self , function_event_name : str , function : typing . Callable , function_type : EventTypes = None , ** kwargs , ): \"\"\"This will register an event command. Usually you would use this if you are using dispike.interactions.on; instead of the self.on. Args: function_event_name (str): Function event name function (typing.Callable): Function to register. Must be async function_type (EventTypes): [description]. Function type, defaults to None, but will still attempt to find the type. Will raise an error if it cannot. Raises: AttributeError: If function_type is not a string or None, and it cannot be found in the functions attributes. \"\"\" if function_type is None : # try to see if the function has a _event_type attribute try : function_type = function . _dispike_event_type except AttributeError : raise AttributeError ( \"Unable to find function event type attribute inside function.. Did you add a decorator to this function?\" ) else : if isinstance ( function_type , EventTypes ): function_type = function_type self . _add_function_to_callbacks ( function_name = function_event_name , function_type = function_type , function = function , )","title":"dispike.main.Dispike.register_event_command"},{"location":"tutorial/Bigger%20Applications/Registering%20Collection/","text":"Registering Collection \u00b6 If you created a collection in a different file, you'll will need to register it with dispike. Warning If your event collection needs to be initialized, do it before passing it to dispike. Otherwise, dispike can initialize it for you.. Passing your arguments to initialization_arguments and let dispike know to initialize it by passing initialze_on_load to register_collection function. from .other_file import SampleCollection from dispike import Dispike bot = Dispike ( ... ) bot . register_collection ( collection = StockTicker , register_command_with_discord = True , # This parameter is optional. ) .register_collection will automatically detect any event callbacks with the interactions.on decorator.","title":"Registering Collections"},{"location":"tutorial/Bigger%20Applications/Registering%20Collection/#registering-collection","text":"If you created a collection in a different file, you'll will need to register it with dispike. Warning If your event collection needs to be initialized, do it before passing it to dispike. Otherwise, dispike can initialize it for you.. Passing your arguments to initialization_arguments and let dispike know to initialize it by passing initialze_on_load to register_collection function. from .other_file import SampleCollection from dispike import Dispike bot = Dispike ( ... ) bot . register_collection ( collection = StockTicker , register_command_with_discord = True , # This parameter is optional. ) .register_collection will automatically detect any event callbacks with the interactions.on decorator.","title":"Registering Collection"},{"location":"tutorial/Bigger%20Applications/Writing%20your%20first%20Collection/","text":"Writing EventCollections \u00b6 Import Dispike interactions, this is a module that contains functions, decorators and classes you'll need to create a collection. from dispike import interactions Create your EventCollection. Create a class and inherit interactions.EventCollection . class SampleCollection ( interactions . EventCollection ): def __init__ ( self , ... ): ... Info An __init__ may be used, but you'll need to let Dispike know to initialize it, or initialize it yourself before passing to dispike. Add your callbacks.. class SampleCollection ( interactions . EventCollection ): def __init__ ( self , ... ): ... @interactions . on ( \"sampleInteractionCommand\" ): async def incoming_interactions_command ( ctx : IncomingDiscordInteraction ): ... @interactions . on ( \"sampleInteractionCommand2\" ): async def incoming_interactions_command_two ( ctx : IncomingDiscordInteraction ): ... @interactions . on ( \"sampleInteractionButton\" , type = EventTypes . COMPONENT ): async def inomcing_interaction_button ( ctx : IncomingDiscordButtonInteraction ): ... @interactions . on ( \"sampleInteractionSelectMenu\" , type = EventType . COMPONENT ): async def incoming_select_menu_interaction ( ctx : IncomingDiscordSelectMenuInteraction ): ... If you followed the tutorial before, this should look extremely familiar. Adding commands. \u00b6 You can also add commands.. You must expose a function named .command_schemas and provide a List containing either PerCommandRegistrationSettings or DiscordCommand items. Dispike offers a helper class called PerCommandRegistrationSettings located in interactions. This class allows you to select where (guild) command will be registered. def command_schemas () -> typing . List [ typing . Union [ PerCommandRegistrationSettings , \"DiscordCommand\" ] ]: return [ DiscordCommand ( name = \"...\" , description = \"...\" , options = [] ), PerCommandRegistrationSettings ( schema = DiscordCommand ( ... ), guild_id = 1111 ) ] You can see in the example above that PerCommandRegistrationSettings is used to target a specific guild.","title":"Writing your First Collection"},{"location":"tutorial/Bigger%20Applications/Writing%20your%20first%20Collection/#writing-eventcollections","text":"Import Dispike interactions, this is a module that contains functions, decorators and classes you'll need to create a collection. from dispike import interactions Create your EventCollection. Create a class and inherit interactions.EventCollection . class SampleCollection ( interactions . EventCollection ): def __init__ ( self , ... ): ... Info An __init__ may be used, but you'll need to let Dispike know to initialize it, or initialize it yourself before passing to dispike. Add your callbacks.. class SampleCollection ( interactions . EventCollection ): def __init__ ( self , ... ): ... @interactions . on ( \"sampleInteractionCommand\" ): async def incoming_interactions_command ( ctx : IncomingDiscordInteraction ): ... @interactions . on ( \"sampleInteractionCommand2\" ): async def incoming_interactions_command_two ( ctx : IncomingDiscordInteraction ): ... @interactions . on ( \"sampleInteractionButton\" , type = EventTypes . COMPONENT ): async def inomcing_interaction_button ( ctx : IncomingDiscordButtonInteraction ): ... @interactions . on ( \"sampleInteractionSelectMenu\" , type = EventType . COMPONENT ): async def incoming_select_menu_interaction ( ctx : IncomingDiscordSelectMenuInteraction ): ... If you followed the tutorial before, this should look extremely familiar.","title":"Writing EventCollections"},{"location":"tutorial/Bigger%20Applications/Writing%20your%20first%20Collection/#adding-commands","text":"You can also add commands.. You must expose a function named .command_schemas and provide a List containing either PerCommandRegistrationSettings or DiscordCommand items. Dispike offers a helper class called PerCommandRegistrationSettings located in interactions. This class allows you to select where (guild) command will be registered. def command_schemas () -> typing . List [ typing . Union [ PerCommandRegistrationSettings , \"DiscordCommand\" ] ]: return [ DiscordCommand ( name = \"...\" , description = \"...\" , options = [] ), PerCommandRegistrationSettings ( schema = DiscordCommand ( ... ), guild_id = 1111 ) ] You can see in the example above that PerCommandRegistrationSettings is used to target a specific guild.","title":"Adding commands."},{"location":"tutorial/Bigger%20Applications/introduction/","text":"Writing Bigger, Organized Projects \u00b6 The earlier tutorial taught you how to write a simple bot. However this may not be reasonable, as you may want to split commands into different files or subfolders. This tutorial is going to show you a sample project that uses the EventCollection class to help you register and 'group' similarly grouped commands.. In this tutorial, we are going to create a sample project, that contains two classes inherited with EventCollection .","title":"Introduction"},{"location":"tutorial/Bigger%20Applications/introduction/#writing-bigger-organized-projects","text":"The earlier tutorial taught you how to write a simple bot. However this may not be reasonable, as you may want to split commands into different files or subfolders. This tutorial is going to show you a sample project that uses the EventCollection class to help you register and 'group' similarly grouped commands.. In this tutorial, we are going to create a sample project, that contains two classes inherited with EventCollection .","title":"Writing Bigger, Organized Projects"}]}